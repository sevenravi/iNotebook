"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/formik";
exports.ids = ["vendor-chunks/formik"];
exports.modules = {

/***/ "(ssr)/../node_modules/formik/dist/formik.esm.js":
/*!*************************************************!*\
  !*** ../node_modules/formik/dist/formik.esm.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ErrorMessage: () => (/* binding */ ErrorMessage),\n/* harmony export */   FastField: () => (/* binding */ FastField),\n/* harmony export */   Field: () => (/* binding */ Field),\n/* harmony export */   FieldArray: () => (/* binding */ FieldArray),\n/* harmony export */   Form: () => (/* binding */ Form),\n/* harmony export */   Formik: () => (/* binding */ Formik),\n/* harmony export */   FormikConsumer: () => (/* binding */ FormikConsumer),\n/* harmony export */   FormikContext: () => (/* binding */ FormikContext),\n/* harmony export */   FormikProvider: () => (/* binding */ FormikProvider),\n/* harmony export */   connect: () => (/* binding */ connect),\n/* harmony export */   getActiveElement: () => (/* binding */ getActiveElement),\n/* harmony export */   getIn: () => (/* binding */ getIn),\n/* harmony export */   insert: () => (/* binding */ insert),\n/* harmony export */   isEmptyArray: () => (/* binding */ isEmptyArray),\n/* harmony export */   isEmptyChildren: () => (/* binding */ isEmptyChildren),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isInputEvent: () => (/* binding */ isInputEvent),\n/* harmony export */   isInteger: () => (/* binding */ isInteger),\n/* harmony export */   isNaN: () => (/* binding */ isNaN$1),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   isPromise: () => (/* binding */ isPromise),\n/* harmony export */   isString: () => (/* binding */ isString),\n/* harmony export */   move: () => (/* binding */ move),\n/* harmony export */   prepareDataForValidation: () => (/* binding */ prepareDataForValidation),\n/* harmony export */   replace: () => (/* binding */ replace),\n/* harmony export */   setIn: () => (/* binding */ setIn),\n/* harmony export */   setNestedObjectValues: () => (/* binding */ setNestedObjectValues),\n/* harmony export */   swap: () => (/* binding */ swap),\n/* harmony export */   useField: () => (/* binding */ useField),\n/* harmony export */   useFormik: () => (/* binding */ useFormik),\n/* harmony export */   useFormikContext: () => (/* binding */ useFormikContext),\n/* harmony export */   validateYupSchema: () => (/* binding */ validateYupSchema),\n/* harmony export */   withFormik: () => (/* binding */ withFormik),\n/* harmony export */   yupToFormErrors: () => (/* binding */ yupToFormErrors)\n/* harmony export */ });\n/* harmony import */ var deepmerge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! deepmerge */ \"(ssr)/../node_modules/deepmerge/dist/es.js\");\n/* harmony import */ var lodash_es_isPlainObject__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash-es/isPlainObject */ \"(ssr)/../node_modules/lodash-es/isPlainObject.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_fast_compare__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-fast-compare */ \"(ssr)/../node_modules/react-fast-compare/index.js\");\n/* harmony import */ var react_fast_compare__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_fast_compare__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var tiny_warning__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tiny-warning */ \"(ssr)/../node_modules/tiny-warning/dist/tiny-warning.esm.js\");\n/* harmony import */ var lodash_es_clone__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash-es/clone */ \"(ssr)/../node_modules/lodash-es/clone.js\");\n/* harmony import */ var lodash_es_toPath__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash-es/toPath */ \"(ssr)/../node_modules/lodash-es/toPath.js\");\n/* harmony import */ var hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! hoist-non-react-statics */ \"(ssr)/../node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js\");\n/* harmony import */ var hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var lodash_es_cloneDeep__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lodash-es/cloneDeep */ \"(ssr)/../node_modules/lodash-es/cloneDeep.js\");\n\n\n\n\n\n\n\n\n\nfunction _extends() {\n    _extends = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    subClass.__proto__ = superClass;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nvar FormikContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nFormikContext.displayName = \"FormikContext\";\nvar FormikProvider = FormikContext.Provider;\nvar FormikConsumer = FormikContext.Consumer;\nfunction useFormikContext() {\n    var formik = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(FormikContext);\n    !!!formik ?  true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(false, \"Formik context is undefined, please verify you are calling useFormikContext() as child of a <Formik> component.\") : 0 : void 0;\n    return formik;\n}\n/** @private is the value an empty array? */ var isEmptyArray = function isEmptyArray(value) {\n    return Array.isArray(value) && value.length === 0;\n};\n/** @private is the given object a Function? */ var isFunction = function isFunction(obj) {\n    return typeof obj === \"function\";\n};\n/** @private is the given object an Object? */ var isObject = function isObject(obj) {\n    return obj !== null && typeof obj === \"object\";\n};\n/** @private is the given object an integer? */ var isInteger = function isInteger(obj) {\n    return String(Math.floor(Number(obj))) === obj;\n};\n/** @private is the given object a string? */ var isString = function isString(obj) {\n    return Object.prototype.toString.call(obj) === \"[object String]\";\n};\n/** @private is the given object a NaN? */ // eslint-disable-next-line no-self-compare\nvar isNaN$1 = function isNaN1(obj) {\n    return obj !== obj;\n};\n/** @private Does a React component have exactly 0 children? */ var isEmptyChildren = function isEmptyChildren(children) {\n    return react__WEBPACK_IMPORTED_MODULE_1__.Children.count(children) === 0;\n};\n/** @private is the given object/value a promise? */ var isPromise = function isPromise(value) {\n    return isObject(value) && isFunction(value.then);\n};\n/** @private is the given object/value a type of synthetic event? */ var isInputEvent = function isInputEvent(value) {\n    return value && isObject(value) && isObject(value.target);\n};\n/**\r\n * Same as document.activeElement but wraps in a try-catch block. In IE it is\r\n * not safe to call document.activeElement if there is nothing focused.\r\n *\r\n * The activeElement will be null only if the document or document body is not\r\n * yet defined.\r\n *\r\n * @param {?Document} doc Defaults to current document.\r\n * @return {Element | null}\r\n * @see https://github.com/facebook/fbjs/blob/master/packages/fbjs/src/core/dom/getActiveElement.js\r\n */ function getActiveElement(doc) {\n    doc = doc || (typeof document !== \"undefined\" ? document : undefined);\n    if (typeof doc === \"undefined\") {\n        return null;\n    }\n    try {\n        return doc.activeElement || doc.body;\n    } catch (e) {\n        return doc.body;\n    }\n}\n/**\r\n * Deeply get a value from an object via its path.\r\n */ function getIn(obj, key, def, p) {\n    if (p === void 0) {\n        p = 0;\n    }\n    var path = (0,lodash_es_toPath__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(key);\n    while(obj && p < path.length){\n        obj = obj[path[p++]];\n    } // check if path is not in the end\n    if (p !== path.length && !obj) {\n        return def;\n    }\n    return obj === undefined ? def : obj;\n}\n/**\r\n * Deeply set a value from in object via it's path. If the value at `path`\r\n * has changed, return a shallow copy of obj with `value` set at `path`.\r\n * If `value` has not changed, return the original `obj`.\r\n *\r\n * Existing objects / arrays along `path` are also shallow copied. Sibling\r\n * objects along path retain the same internal js reference. Since new\r\n * objects / arrays are only created along `path`, we can test if anything\r\n * changed in a nested structure by comparing the object's reference in\r\n * the old and new object, similar to how russian doll cache invalidation\r\n * works.\r\n *\r\n * In earlier versions of this function, which used cloneDeep, there were\r\n * issues whereby settings a nested value would mutate the parent\r\n * instead of creating a new object. `clone` avoids that bug making a\r\n * shallow copy of the objects along the update path\r\n * so no object is mutated in place.\r\n *\r\n * Before changing this function, please read through the following\r\n * discussions.\r\n *\r\n * @see https://github.com/developit/linkstate\r\n * @see https://github.com/jaredpalmer/formik/pull/123\r\n */ function setIn(obj, path, value) {\n    var res = (0,lodash_es_clone__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(obj); // this keeps inheritance when obj is a class\n    var resVal = res;\n    var i = 0;\n    var pathArray = (0,lodash_es_toPath__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(path);\n    for(; i < pathArray.length - 1; i++){\n        var currentPath = pathArray[i];\n        var currentObj = getIn(obj, pathArray.slice(0, i + 1));\n        if (currentObj && (isObject(currentObj) || Array.isArray(currentObj))) {\n            resVal = resVal[currentPath] = (0,lodash_es_clone__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(currentObj);\n        } else {\n            var nextPath = pathArray[i + 1];\n            resVal = resVal[currentPath] = isInteger(nextPath) && Number(nextPath) >= 0 ? [] : {};\n        }\n    } // Return original object if new value is the same as current\n    if ((i === 0 ? obj : resVal)[pathArray[i]] === value) {\n        return obj;\n    }\n    if (value === undefined) {\n        delete resVal[pathArray[i]];\n    } else {\n        resVal[pathArray[i]] = value;\n    } // If the path array has a single element, the loop did not run.\n    // Deleting on `resVal` had no effect in this scenario, so we delete on the result instead.\n    if (i === 0 && value === undefined) {\n        delete res[pathArray[i]];\n    }\n    return res;\n}\n/**\r\n * Recursively a set the same value for all keys and arrays nested object, cloning\r\n * @param object\r\n * @param value\r\n * @param visited\r\n * @param response\r\n */ function setNestedObjectValues(object, value, visited, response) {\n    if (visited === void 0) {\n        visited = new WeakMap();\n    }\n    if (response === void 0) {\n        response = {};\n    }\n    for(var _i = 0, _Object$keys = Object.keys(object); _i < _Object$keys.length; _i++){\n        var k = _Object$keys[_i];\n        var val = object[k];\n        if (isObject(val)) {\n            if (!visited.get(val)) {\n                visited.set(val, true); // In order to keep array values consistent for both dot path  and\n                // bracket syntax, we need to check if this is an array so that\n                // this will output  { friends: [true] } and not { friends: { \"0\": true } }\n                response[k] = Array.isArray(val) ? [] : {};\n                setNestedObjectValues(val, value, visited, response[k]);\n            }\n        } else {\n            response[k] = value;\n        }\n    }\n    return response;\n}\nfunction formikReducer(state, msg) {\n    switch(msg.type){\n        case \"SET_VALUES\":\n            return _extends({}, state, {\n                values: msg.payload\n            });\n        case \"SET_TOUCHED\":\n            return _extends({}, state, {\n                touched: msg.payload\n            });\n        case \"SET_ERRORS\":\n            if (react_fast_compare__WEBPACK_IMPORTED_MODULE_2___default()(state.errors, msg.payload)) {\n                return state;\n            }\n            return _extends({}, state, {\n                errors: msg.payload\n            });\n        case \"SET_STATUS\":\n            return _extends({}, state, {\n                status: msg.payload\n            });\n        case \"SET_ISSUBMITTING\":\n            return _extends({}, state, {\n                isSubmitting: msg.payload\n            });\n        case \"SET_ISVALIDATING\":\n            return _extends({}, state, {\n                isValidating: msg.payload\n            });\n        case \"SET_FIELD_VALUE\":\n            return _extends({}, state, {\n                values: setIn(state.values, msg.payload.field, msg.payload.value)\n            });\n        case \"SET_FIELD_TOUCHED\":\n            return _extends({}, state, {\n                touched: setIn(state.touched, msg.payload.field, msg.payload.value)\n            });\n        case \"SET_FIELD_ERROR\":\n            return _extends({}, state, {\n                errors: setIn(state.errors, msg.payload.field, msg.payload.value)\n            });\n        case \"RESET_FORM\":\n            return _extends({}, state, msg.payload);\n        case \"SET_FORMIK_STATE\":\n            return msg.payload(state);\n        case \"SUBMIT_ATTEMPT\":\n            return _extends({}, state, {\n                touched: setNestedObjectValues(state.values, true),\n                isSubmitting: true,\n                submitCount: state.submitCount + 1\n            });\n        case \"SUBMIT_FAILURE\":\n            return _extends({}, state, {\n                isSubmitting: false\n            });\n        case \"SUBMIT_SUCCESS\":\n            return _extends({}, state, {\n                isSubmitting: false\n            });\n        default:\n            return state;\n    }\n} // Initial empty states // objects\nvar emptyErrors = {};\nvar emptyTouched = {};\nfunction useFormik(_ref) {\n    var _ref$validateOnChange = _ref.validateOnChange, validateOnChange = _ref$validateOnChange === void 0 ? true : _ref$validateOnChange, _ref$validateOnBlur = _ref.validateOnBlur, validateOnBlur = _ref$validateOnBlur === void 0 ? true : _ref$validateOnBlur, _ref$validateOnMount = _ref.validateOnMount, validateOnMount = _ref$validateOnMount === void 0 ? false : _ref$validateOnMount, isInitialValid = _ref.isInitialValid, _ref$enableReinitiali = _ref.enableReinitialize, enableReinitialize = _ref$enableReinitiali === void 0 ? false : _ref$enableReinitiali, onSubmit = _ref.onSubmit, rest = _objectWithoutPropertiesLoose(_ref, [\n        \"validateOnChange\",\n        \"validateOnBlur\",\n        \"validateOnMount\",\n        \"isInitialValid\",\n        \"enableReinitialize\",\n        \"onSubmit\"\n    ]);\n    var props = _extends({\n        validateOnChange: validateOnChange,\n        validateOnBlur: validateOnBlur,\n        validateOnMount: validateOnMount,\n        onSubmit: onSubmit\n    }, rest);\n    var initialValues = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(props.initialValues);\n    var initialErrors = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(props.initialErrors || emptyErrors);\n    var initialTouched = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(props.initialTouched || emptyTouched);\n    var initialStatus = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(props.initialStatus);\n    var isMounted = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    var fieldRegistry = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({});\n    if (true) {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n            !(typeof isInitialValid === \"undefined\") ?  true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(false, \"isInitialValid has been deprecated and will be removed in future versions of Formik. Please use initialErrors or validateOnMount instead.\") : 0 : void 0; // eslint-disable-next-line\n        }, []);\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n        isMounted.current = true;\n        return function() {\n            isMounted.current = false;\n        };\n    }, []);\n    var _React$useState = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0), setIteration = _React$useState[1];\n    var stateRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({\n        values: props.initialValues,\n        errors: props.initialErrors || emptyErrors,\n        touched: props.initialTouched || emptyTouched,\n        status: props.initialStatus,\n        isSubmitting: false,\n        isValidating: false,\n        submitCount: 0\n    });\n    var state = stateRef.current;\n    var dispatch = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(action) {\n        var prev = stateRef.current;\n        stateRef.current = formikReducer(prev, action); // force rerender\n        if (prev !== stateRef.current) setIteration(function(x) {\n            return x + 1;\n        });\n    }, []);\n    var runValidateHandler = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(values, field) {\n        return new Promise(function(resolve, reject) {\n            var maybePromisedErrors = props.validate(values, field);\n            if (maybePromisedErrors == null) {\n                // use loose null check here on purpose\n                resolve(emptyErrors);\n            } else if (isPromise(maybePromisedErrors)) {\n                maybePromisedErrors.then(function(errors) {\n                    resolve(errors || emptyErrors);\n                }, function(actualException) {\n                    if (true) {\n                        console.warn(\"Warning: An unhandled error was caught during validation in <Formik validate />\", actualException);\n                    }\n                    reject(actualException);\n                });\n            } else {\n                resolve(maybePromisedErrors);\n            }\n        });\n    }, [\n        props.validate\n    ]);\n    /**\r\n   * Run validation against a Yup schema and optionally run a function if successful\r\n   */ var runValidationSchema = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(values, field) {\n        var validationSchema = props.validationSchema;\n        var schema = isFunction(validationSchema) ? validationSchema(field) : validationSchema;\n        var promise = field && schema.validateAt ? schema.validateAt(field, values) : validateYupSchema(values, schema);\n        return new Promise(function(resolve, reject) {\n            promise.then(function() {\n                resolve(emptyErrors);\n            }, function(err) {\n                // Yup will throw a validation error if validation fails. We catch those and\n                // resolve them into Formik errors. We can sniff if something is a Yup error\n                // by checking error.name.\n                // @see https://github.com/jquense/yup#validationerrorerrors-string--arraystring-value-any-path-string\n                if (err.name === \"ValidationError\") {\n                    resolve(yupToFormErrors(err));\n                } else {\n                    // We throw any other errors\n                    if (true) {\n                        console.warn(\"Warning: An unhandled error was caught during validation in <Formik validationSchema />\", err);\n                    }\n                    reject(err);\n                }\n            });\n        });\n    }, [\n        props.validationSchema\n    ]);\n    var runSingleFieldLevelValidation = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(field, value) {\n        return new Promise(function(resolve) {\n            return resolve(fieldRegistry.current[field].validate(value));\n        });\n    }, []);\n    var runFieldLevelValidations = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(values) {\n        var fieldKeysWithValidation = Object.keys(fieldRegistry.current).filter(function(f) {\n            return isFunction(fieldRegistry.current[f].validate);\n        }); // Construct an array with all of the field validation functions\n        var fieldValidations = fieldKeysWithValidation.length > 0 ? fieldKeysWithValidation.map(function(f) {\n            return runSingleFieldLevelValidation(f, getIn(values, f));\n        }) : [\n            Promise.resolve(\"DO_NOT_DELETE_YOU_WILL_BE_FIRED\")\n        ]; // use special case ;)\n        return Promise.all(fieldValidations).then(function(fieldErrorsList) {\n            return fieldErrorsList.reduce(function(prev, curr, index) {\n                if (curr === \"DO_NOT_DELETE_YOU_WILL_BE_FIRED\") {\n                    return prev;\n                }\n                if (curr) {\n                    prev = setIn(prev, fieldKeysWithValidation[index], curr);\n                }\n                return prev;\n            }, {});\n        });\n    }, [\n        runSingleFieldLevelValidation\n    ]); // Run all validations and return the result\n    var runAllValidations = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(values) {\n        return Promise.all([\n            runFieldLevelValidations(values),\n            props.validationSchema ? runValidationSchema(values) : {},\n            props.validate ? runValidateHandler(values) : {}\n        ]).then(function(_ref2) {\n            var fieldErrors = _ref2[0], schemaErrors = _ref2[1], validateErrors = _ref2[2];\n            var combinedErrors = deepmerge__WEBPACK_IMPORTED_MODULE_0__[\"default\"].all([\n                fieldErrors,\n                schemaErrors,\n                validateErrors\n            ], {\n                arrayMerge: arrayMerge\n            });\n            return combinedErrors;\n        });\n    }, [\n        props.validate,\n        props.validationSchema,\n        runFieldLevelValidations,\n        runValidateHandler,\n        runValidationSchema\n    ]); // Run all validations methods and update state accordingly\n    var validateFormWithHighPriority = useEventCallback(function(values) {\n        if (values === void 0) {\n            values = state.values;\n        }\n        dispatch({\n            type: \"SET_ISVALIDATING\",\n            payload: true\n        });\n        return runAllValidations(values).then(function(combinedErrors) {\n            if (!!isMounted.current) {\n                dispatch({\n                    type: \"SET_ISVALIDATING\",\n                    payload: false\n                });\n                dispatch({\n                    type: \"SET_ERRORS\",\n                    payload: combinedErrors\n                });\n            }\n            return combinedErrors;\n        });\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n        if (validateOnMount && isMounted.current === true && react_fast_compare__WEBPACK_IMPORTED_MODULE_2___default()(initialValues.current, props.initialValues)) {\n            validateFormWithHighPriority(initialValues.current);\n        }\n    }, [\n        validateOnMount,\n        validateFormWithHighPriority\n    ]);\n    var resetForm = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(nextState) {\n        var values = nextState && nextState.values ? nextState.values : initialValues.current;\n        var errors = nextState && nextState.errors ? nextState.errors : initialErrors.current ? initialErrors.current : props.initialErrors || {};\n        var touched = nextState && nextState.touched ? nextState.touched : initialTouched.current ? initialTouched.current : props.initialTouched || {};\n        var status = nextState && nextState.status ? nextState.status : initialStatus.current ? initialStatus.current : props.initialStatus;\n        initialValues.current = values;\n        initialErrors.current = errors;\n        initialTouched.current = touched;\n        initialStatus.current = status;\n        var dispatchFn = function dispatchFn() {\n            dispatch({\n                type: \"RESET_FORM\",\n                payload: {\n                    isSubmitting: !!nextState && !!nextState.isSubmitting,\n                    errors: errors,\n                    touched: touched,\n                    status: status,\n                    values: values,\n                    isValidating: !!nextState && !!nextState.isValidating,\n                    submitCount: !!nextState && !!nextState.submitCount && typeof nextState.submitCount === \"number\" ? nextState.submitCount : 0\n                }\n            });\n        };\n        if (props.onReset) {\n            var maybePromisedOnReset = props.onReset(state.values, imperativeMethods);\n            if (isPromise(maybePromisedOnReset)) {\n                maybePromisedOnReset.then(dispatchFn);\n            } else {\n                dispatchFn();\n            }\n        } else {\n            dispatchFn();\n        }\n    }, [\n        props.initialErrors,\n        props.initialStatus,\n        props.initialTouched,\n        props.onReset\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n        if (isMounted.current === true && !react_fast_compare__WEBPACK_IMPORTED_MODULE_2___default()(initialValues.current, props.initialValues)) {\n            if (enableReinitialize) {\n                initialValues.current = props.initialValues;\n                resetForm();\n                if (validateOnMount) {\n                    validateFormWithHighPriority(initialValues.current);\n                }\n            }\n        }\n    }, [\n        enableReinitialize,\n        props.initialValues,\n        resetForm,\n        validateOnMount,\n        validateFormWithHighPriority\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n        if (enableReinitialize && isMounted.current === true && !react_fast_compare__WEBPACK_IMPORTED_MODULE_2___default()(initialErrors.current, props.initialErrors)) {\n            initialErrors.current = props.initialErrors || emptyErrors;\n            dispatch({\n                type: \"SET_ERRORS\",\n                payload: props.initialErrors || emptyErrors\n            });\n        }\n    }, [\n        enableReinitialize,\n        props.initialErrors\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n        if (enableReinitialize && isMounted.current === true && !react_fast_compare__WEBPACK_IMPORTED_MODULE_2___default()(initialTouched.current, props.initialTouched)) {\n            initialTouched.current = props.initialTouched || emptyTouched;\n            dispatch({\n                type: \"SET_TOUCHED\",\n                payload: props.initialTouched || emptyTouched\n            });\n        }\n    }, [\n        enableReinitialize,\n        props.initialTouched\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n        if (enableReinitialize && isMounted.current === true && !react_fast_compare__WEBPACK_IMPORTED_MODULE_2___default()(initialStatus.current, props.initialStatus)) {\n            initialStatus.current = props.initialStatus;\n            dispatch({\n                type: \"SET_STATUS\",\n                payload: props.initialStatus\n            });\n        }\n    }, [\n        enableReinitialize,\n        props.initialStatus,\n        props.initialTouched\n    ]);\n    var validateField = useEventCallback(function(name) {\n        // This will efficiently validate a single field by avoiding state\n        // changes if the validation function is synchronous. It's different from\n        // what is called when using validateForm.\n        if (fieldRegistry.current[name] && isFunction(fieldRegistry.current[name].validate)) {\n            var value = getIn(state.values, name);\n            var maybePromise = fieldRegistry.current[name].validate(value);\n            if (isPromise(maybePromise)) {\n                // Only flip isValidating if the function is async.\n                dispatch({\n                    type: \"SET_ISVALIDATING\",\n                    payload: true\n                });\n                return maybePromise.then(function(x) {\n                    return x;\n                }).then(function(error) {\n                    dispatch({\n                        type: \"SET_FIELD_ERROR\",\n                        payload: {\n                            field: name,\n                            value: error\n                        }\n                    });\n                    dispatch({\n                        type: \"SET_ISVALIDATING\",\n                        payload: false\n                    });\n                });\n            } else {\n                dispatch({\n                    type: \"SET_FIELD_ERROR\",\n                    payload: {\n                        field: name,\n                        value: maybePromise\n                    }\n                });\n                return Promise.resolve(maybePromise);\n            }\n        } else if (props.validationSchema) {\n            dispatch({\n                type: \"SET_ISVALIDATING\",\n                payload: true\n            });\n            return runValidationSchema(state.values, name).then(function(x) {\n                return x;\n            }).then(function(error) {\n                dispatch({\n                    type: \"SET_FIELD_ERROR\",\n                    payload: {\n                        field: name,\n                        value: getIn(error, name)\n                    }\n                });\n                dispatch({\n                    type: \"SET_ISVALIDATING\",\n                    payload: false\n                });\n            });\n        }\n        return Promise.resolve();\n    });\n    var registerField = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(name, _ref3) {\n        var validate = _ref3.validate;\n        fieldRegistry.current[name] = {\n            validate: validate\n        };\n    }, []);\n    var unregisterField = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(name) {\n        delete fieldRegistry.current[name];\n    }, []);\n    var setTouched = useEventCallback(function(touched, shouldValidate) {\n        dispatch({\n            type: \"SET_TOUCHED\",\n            payload: touched\n        });\n        var willValidate = shouldValidate === undefined ? validateOnBlur : shouldValidate;\n        return willValidate ? validateFormWithHighPriority(state.values) : Promise.resolve();\n    });\n    var setErrors = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(errors) {\n        dispatch({\n            type: \"SET_ERRORS\",\n            payload: errors\n        });\n    }, []);\n    var setValues = useEventCallback(function(values, shouldValidate) {\n        var resolvedValues = isFunction(values) ? values(state.values) : values;\n        dispatch({\n            type: \"SET_VALUES\",\n            payload: resolvedValues\n        });\n        var willValidate = shouldValidate === undefined ? validateOnChange : shouldValidate;\n        return willValidate ? validateFormWithHighPriority(resolvedValues) : Promise.resolve();\n    });\n    var setFieldError = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(field, value) {\n        dispatch({\n            type: \"SET_FIELD_ERROR\",\n            payload: {\n                field: field,\n                value: value\n            }\n        });\n    }, []);\n    var setFieldValue = useEventCallback(function(field, value, shouldValidate) {\n        dispatch({\n            type: \"SET_FIELD_VALUE\",\n            payload: {\n                field: field,\n                value: value\n            }\n        });\n        var willValidate = shouldValidate === undefined ? validateOnChange : shouldValidate;\n        return willValidate ? validateFormWithHighPriority(setIn(state.values, field, value)) : Promise.resolve();\n    });\n    var executeChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(eventOrTextValue, maybePath) {\n        // By default, assume that the first argument is a string. This allows us to use\n        // handleChange with React Native and React Native Web's onChangeText prop which\n        // provides just the value of the input.\n        var field = maybePath;\n        var val = eventOrTextValue;\n        var parsed; // If the first argument is not a string though, it has to be a synthetic React Event (or a fake one),\n        // so we handle like we would a normal HTML change event.\n        if (!isString(eventOrTextValue)) {\n            // If we can, persist the event\n            // @see https://reactjs.org/docs/events.html#event-pooling\n            if (eventOrTextValue.persist) {\n                eventOrTextValue.persist();\n            }\n            var target = eventOrTextValue.target ? eventOrTextValue.target : eventOrTextValue.currentTarget;\n            var type = target.type, name = target.name, id = target.id, value = target.value, checked = target.checked, outerHTML = target.outerHTML, options = target.options, multiple = target.multiple;\n            field = maybePath ? maybePath : name ? name : id;\n            if (!field && \"development\" !== \"production\") {\n                warnAboutMissingIdentifier({\n                    htmlContent: outerHTML,\n                    documentationAnchorLink: \"handlechange-e-reactchangeeventany--void\",\n                    handlerName: \"handleChange\"\n                });\n            }\n            val = /number|range/.test(type) ? (parsed = parseFloat(value), isNaN(parsed) ? \"\" : parsed) : /checkbox/.test(type) // checkboxes\n             ? getValueForCheckbox(getIn(state.values, field), checked, value) : options && multiple // <select multiple>\n             ? getSelectedValues(options) : value;\n        }\n        if (field) {\n            // Set form fields by name\n            setFieldValue(field, val);\n        }\n    }, [\n        setFieldValue,\n        state.values\n    ]);\n    var handleChange = useEventCallback(function(eventOrPath) {\n        if (isString(eventOrPath)) {\n            return function(event) {\n                return executeChange(event, eventOrPath);\n            };\n        } else {\n            executeChange(eventOrPath);\n        }\n    });\n    var setFieldTouched = useEventCallback(function(field, touched, shouldValidate) {\n        if (touched === void 0) {\n            touched = true;\n        }\n        dispatch({\n            type: \"SET_FIELD_TOUCHED\",\n            payload: {\n                field: field,\n                value: touched\n            }\n        });\n        var willValidate = shouldValidate === undefined ? validateOnBlur : shouldValidate;\n        return willValidate ? validateFormWithHighPriority(state.values) : Promise.resolve();\n    });\n    var executeBlur = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(e, path) {\n        if (e.persist) {\n            e.persist();\n        }\n        var _e$target = e.target, name = _e$target.name, id = _e$target.id, outerHTML = _e$target.outerHTML;\n        var field = path ? path : name ? name : id;\n        if (!field && \"development\" !== \"production\") {\n            warnAboutMissingIdentifier({\n                htmlContent: outerHTML,\n                documentationAnchorLink: \"handleblur-e-any--void\",\n                handlerName: \"handleBlur\"\n            });\n        }\n        setFieldTouched(field, true);\n    }, [\n        setFieldTouched\n    ]);\n    var handleBlur = useEventCallback(function(eventOrString) {\n        if (isString(eventOrString)) {\n            return function(event) {\n                return executeBlur(event, eventOrString);\n            };\n        } else {\n            executeBlur(eventOrString);\n        }\n    });\n    var setFormikState = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(stateOrCb) {\n        if (isFunction(stateOrCb)) {\n            dispatch({\n                type: \"SET_FORMIK_STATE\",\n                payload: stateOrCb\n            });\n        } else {\n            dispatch({\n                type: \"SET_FORMIK_STATE\",\n                payload: function payload() {\n                    return stateOrCb;\n                }\n            });\n        }\n    }, []);\n    var setStatus = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(status) {\n        dispatch({\n            type: \"SET_STATUS\",\n            payload: status\n        });\n    }, []);\n    var setSubmitting = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(isSubmitting) {\n        dispatch({\n            type: \"SET_ISSUBMITTING\",\n            payload: isSubmitting\n        });\n    }, []);\n    var submitForm = useEventCallback(function() {\n        dispatch({\n            type: \"SUBMIT_ATTEMPT\"\n        });\n        return validateFormWithHighPriority().then(function(combinedErrors) {\n            // In case an error was thrown and passed to the resolved Promise,\n            // `combinedErrors` can be an instance of an Error. We need to check\n            // that and abort the submit.\n            // If we don't do that, calling `Object.keys(new Error())` yields an\n            // empty array, which causes the validation to pass and the form\n            // to be submitted.\n            var isInstanceOfError = combinedErrors instanceof Error;\n            var isActuallyValid = !isInstanceOfError && Object.keys(combinedErrors).length === 0;\n            if (isActuallyValid) {\n                // Proceed with submit...\n                //\n                // To respect sync submit fns, we can't simply wrap executeSubmit in a promise and\n                // _always_ dispatch SUBMIT_SUCCESS because isSubmitting would then always be false.\n                // This would be fine in simple cases, but make it impossible to disable submit\n                // buttons where people use callbacks or promises as side effects (which is basically\n                // all of v1 Formik code). Instead, recall that we are inside of a promise chain already,\n                //  so we can try/catch executeSubmit(), if it returns undefined, then just bail.\n                // If there are errors, throw em. Otherwise, wrap executeSubmit in a promise and handle\n                // cleanup of isSubmitting on behalf of the consumer.\n                var promiseOrUndefined;\n                try {\n                    promiseOrUndefined = executeSubmit(); // Bail if it's sync, consumer is responsible for cleaning up\n                    // via setSubmitting(false)\n                    if (promiseOrUndefined === undefined) {\n                        return;\n                    }\n                } catch (error) {\n                    throw error;\n                }\n                return Promise.resolve(promiseOrUndefined).then(function(result) {\n                    if (!!isMounted.current) {\n                        dispatch({\n                            type: \"SUBMIT_SUCCESS\"\n                        });\n                    }\n                    return result;\n                })[\"catch\"](function(_errors) {\n                    if (!!isMounted.current) {\n                        dispatch({\n                            type: \"SUBMIT_FAILURE\"\n                        }); // This is a legit error rejected by the onSubmit fn\n                        // so we don't want to break the promise chain\n                        throw _errors;\n                    }\n                });\n            } else if (!!isMounted.current) {\n                // ^^^ Make sure Formik is still mounted before updating state\n                dispatch({\n                    type: \"SUBMIT_FAILURE\"\n                }); // throw combinedErrors;\n                if (isInstanceOfError) {\n                    throw combinedErrors;\n                }\n            }\n            return;\n        });\n    });\n    var handleSubmit = useEventCallback(function(e) {\n        if (e && e.preventDefault && isFunction(e.preventDefault)) {\n            e.preventDefault();\n        }\n        if (e && e.stopPropagation && isFunction(e.stopPropagation)) {\n            e.stopPropagation();\n        } // Warn if form submission is triggered by a <button> without a\n        // specified `type` attribute during development. This mitigates\n        // a common gotcha in forms with both reset and submit buttons,\n        // where the dev forgets to add type=\"button\" to the reset button.\n        if ( true && typeof document !== \"undefined\") {\n            // Safely get the active element (works with IE)\n            var activeElement = getActiveElement();\n            if (activeElement !== null && activeElement instanceof HTMLButtonElement) {\n                !(activeElement.attributes && activeElement.attributes.getNamedItem(\"type\")) ?  true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(false, 'You submitted a Formik form using a button with an unspecified `type` attribute.  Most browsers default button elements to `type=\"submit\"`. If this is not a submit button, please add `type=\"button\"`.') : 0 : void 0;\n            }\n        }\n        submitForm()[\"catch\"](function(reason) {\n            console.warn(\"Warning: An unhandled error was caught from submitForm()\", reason);\n        });\n    });\n    var imperativeMethods = {\n        resetForm: resetForm,\n        validateForm: validateFormWithHighPriority,\n        validateField: validateField,\n        setErrors: setErrors,\n        setFieldError: setFieldError,\n        setFieldTouched: setFieldTouched,\n        setFieldValue: setFieldValue,\n        setStatus: setStatus,\n        setSubmitting: setSubmitting,\n        setTouched: setTouched,\n        setValues: setValues,\n        setFormikState: setFormikState,\n        submitForm: submitForm\n    };\n    var executeSubmit = useEventCallback(function() {\n        return onSubmit(state.values, imperativeMethods);\n    });\n    var handleReset = useEventCallback(function(e) {\n        if (e && e.preventDefault && isFunction(e.preventDefault)) {\n            e.preventDefault();\n        }\n        if (e && e.stopPropagation && isFunction(e.stopPropagation)) {\n            e.stopPropagation();\n        }\n        resetForm();\n    });\n    var getFieldMeta = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(name) {\n        return {\n            value: getIn(state.values, name),\n            error: getIn(state.errors, name),\n            touched: !!getIn(state.touched, name),\n            initialValue: getIn(initialValues.current, name),\n            initialTouched: !!getIn(initialTouched.current, name),\n            initialError: getIn(initialErrors.current, name)\n        };\n    }, [\n        state.errors,\n        state.touched,\n        state.values\n    ]);\n    var getFieldHelpers = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(name) {\n        return {\n            setValue: function setValue(value, shouldValidate) {\n                return setFieldValue(name, value, shouldValidate);\n            },\n            setTouched: function setTouched(value, shouldValidate) {\n                return setFieldTouched(name, value, shouldValidate);\n            },\n            setError: function setError(value) {\n                return setFieldError(name, value);\n            }\n        };\n    }, [\n        setFieldValue,\n        setFieldTouched,\n        setFieldError\n    ]);\n    var getFieldProps = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(nameOrOptions) {\n        var isAnObject = isObject(nameOrOptions);\n        var name = isAnObject ? nameOrOptions.name : nameOrOptions;\n        var valueState = getIn(state.values, name);\n        var field = {\n            name: name,\n            value: valueState,\n            onChange: handleChange,\n            onBlur: handleBlur\n        };\n        if (isAnObject) {\n            var type = nameOrOptions.type, valueProp = nameOrOptions.value, is = nameOrOptions.as, multiple = nameOrOptions.multiple;\n            if (type === \"checkbox\") {\n                if (valueProp === undefined) {\n                    field.checked = !!valueState;\n                } else {\n                    field.checked = !!(Array.isArray(valueState) && ~valueState.indexOf(valueProp));\n                    field.value = valueProp;\n                }\n            } else if (type === \"radio\") {\n                field.checked = valueState === valueProp;\n                field.value = valueProp;\n            } else if (is === \"select\" && multiple) {\n                field.value = field.value || [];\n                field.multiple = true;\n            }\n        }\n        return field;\n    }, [\n        handleBlur,\n        handleChange,\n        state.values\n    ]);\n    var dirty = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(function() {\n        return !react_fast_compare__WEBPACK_IMPORTED_MODULE_2___default()(initialValues.current, state.values);\n    }, [\n        initialValues.current,\n        state.values\n    ]);\n    var isValid = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(function() {\n        return typeof isInitialValid !== \"undefined\" ? dirty ? state.errors && Object.keys(state.errors).length === 0 : isInitialValid !== false && isFunction(isInitialValid) ? isInitialValid(props) : isInitialValid : state.errors && Object.keys(state.errors).length === 0;\n    }, [\n        isInitialValid,\n        dirty,\n        state.errors,\n        props\n    ]);\n    var ctx = _extends({}, state, {\n        initialValues: initialValues.current,\n        initialErrors: initialErrors.current,\n        initialTouched: initialTouched.current,\n        initialStatus: initialStatus.current,\n        handleBlur: handleBlur,\n        handleChange: handleChange,\n        handleReset: handleReset,\n        handleSubmit: handleSubmit,\n        resetForm: resetForm,\n        setErrors: setErrors,\n        setFormikState: setFormikState,\n        setFieldTouched: setFieldTouched,\n        setFieldValue: setFieldValue,\n        setFieldError: setFieldError,\n        setStatus: setStatus,\n        setSubmitting: setSubmitting,\n        setTouched: setTouched,\n        setValues: setValues,\n        submitForm: submitForm,\n        validateForm: validateFormWithHighPriority,\n        validateField: validateField,\n        isValid: isValid,\n        dirty: dirty,\n        unregisterField: unregisterField,\n        registerField: registerField,\n        getFieldProps: getFieldProps,\n        getFieldMeta: getFieldMeta,\n        getFieldHelpers: getFieldHelpers,\n        validateOnBlur: validateOnBlur,\n        validateOnChange: validateOnChange,\n        validateOnMount: validateOnMount\n    });\n    return ctx;\n}\nfunction Formik(props) {\n    var formikbag = useFormik(props);\n    var component = props.component, children = props.children, render = props.render, innerRef = props.innerRef; // This allows folks to pass a ref to <Formik />\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle)(innerRef, function() {\n        return formikbag;\n    });\n    if (true) {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n            !!props.render ?  true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(false, \"<Formik render> has been deprecated and will be removed in future versions of Formik. Please use a child callback function instead. To get rid of this warning, replace <Formik render={(props) => ...} /> with <Formik>{(props) => ...}</Formik>\") : 0 : void 0; // eslint-disable-next-line\n        }, []);\n    }\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(FormikProvider, {\n        value: formikbag\n    }, component ? /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(component, formikbag) : render ? render(formikbag) : children // children come last, always called\n     ? isFunction(children) ? children(formikbag) : !isEmptyChildren(children) ? react__WEBPACK_IMPORTED_MODULE_1__.Children.only(children) : null : null);\n}\nfunction warnAboutMissingIdentifier(_ref4) {\n    var htmlContent = _ref4.htmlContent, documentationAnchorLink = _ref4.documentationAnchorLink, handlerName = _ref4.handlerName;\n    console.warn(\"Warning: Formik called `\" + handlerName + \"`, but you forgot to pass an `id` or `name` attribute to your input:\\n    \" + htmlContent + \"\\n    Formik cannot determine which value to update. For more info see https://formik.org/docs/api/formik#\" + documentationAnchorLink + \"\\n  \");\n}\n/**\r\n * Transform Yup ValidationError to a more usable object\r\n */ function yupToFormErrors(yupError) {\n    var errors = {};\n    if (yupError.inner) {\n        if (yupError.inner.length === 0) {\n            return setIn(errors, yupError.path, yupError.message);\n        }\n        for(var _iterator = yupError.inner, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;){\n            var _ref5;\n            if (_isArray) {\n                if (_i >= _iterator.length) break;\n                _ref5 = _iterator[_i++];\n            } else {\n                _i = _iterator.next();\n                if (_i.done) break;\n                _ref5 = _i.value;\n            }\n            var err = _ref5;\n            if (!getIn(errors, err.path)) {\n                errors = setIn(errors, err.path, err.message);\n            }\n        }\n    }\n    return errors;\n}\n/**\r\n * Validate a yup schema.\r\n */ function validateYupSchema(values, schema, sync, context) {\n    if (sync === void 0) {\n        sync = false;\n    }\n    var normalizedValues = prepareDataForValidation(values);\n    return schema[sync ? \"validateSync\" : \"validate\"](normalizedValues, {\n        abortEarly: false,\n        context: context || normalizedValues\n    });\n}\n/**\r\n * Recursively prepare values.\r\n */ function prepareDataForValidation(values) {\n    var data = Array.isArray(values) ? [] : {};\n    for(var k in values){\n        if (Object.prototype.hasOwnProperty.call(values, k)) {\n            var key = String(k);\n            if (Array.isArray(values[key]) === true) {\n                data[key] = values[key].map(function(value) {\n                    if (Array.isArray(value) === true || (0,lodash_es_isPlainObject__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(value)) {\n                        return prepareDataForValidation(value);\n                    } else {\n                        return value !== \"\" ? value : undefined;\n                    }\n                });\n            } else if ((0,lodash_es_isPlainObject__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(values[key])) {\n                data[key] = prepareDataForValidation(values[key]);\n            } else {\n                data[key] = values[key] !== \"\" ? values[key] : undefined;\n            }\n        }\n    }\n    return data;\n}\n/**\r\n * deepmerge array merging algorithm\r\n * https://github.com/KyleAMathews/deepmerge#combine-array\r\n */ function arrayMerge(target, source, options) {\n    var destination = target.slice();\n    source.forEach(function merge(e, i) {\n        if (typeof destination[i] === \"undefined\") {\n            var cloneRequested = options.clone !== false;\n            var shouldClone = cloneRequested && options.isMergeableObject(e);\n            destination[i] = shouldClone ? (0,deepmerge__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(Array.isArray(e) ? [] : {}, e, options) : e;\n        } else if (options.isMergeableObject(e)) {\n            destination[i] = (0,deepmerge__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(target[i], e, options);\n        } else if (target.indexOf(e) === -1) {\n            destination.push(e);\n        }\n    });\n    return destination;\n}\n/** Return multi select values based on an array of options */ function getSelectedValues(options) {\n    return Array.from(options).filter(function(el) {\n        return el.selected;\n    }).map(function(el) {\n        return el.value;\n    });\n}\n/** Return the next value for a checkbox */ function getValueForCheckbox(currentValue, checked, valueProp) {\n    // If the current value was a boolean, return a boolean\n    if (typeof currentValue === \"boolean\") {\n        return Boolean(checked);\n    } // If the currentValue was not a boolean we want to return an array\n    var currentArrayOfValues = [];\n    var isValueInArray = false;\n    var index = -1;\n    if (!Array.isArray(currentValue)) {\n        // eslint-disable-next-line eqeqeq\n        if (!valueProp || valueProp == \"true\" || valueProp == \"false\") {\n            return Boolean(checked);\n        }\n    } else {\n        // If the current value is already an array, use it\n        currentArrayOfValues = currentValue;\n        index = currentValue.indexOf(valueProp);\n        isValueInArray = index >= 0;\n    } // If the checkbox was checked and the value is not already present in the aray we want to add the new value to the array of values\n    if (checked && valueProp && !isValueInArray) {\n        return currentArrayOfValues.concat(valueProp);\n    } // If the checkbox was unchecked and the value is not in the array, simply return the already existing array of values\n    if (!isValueInArray) {\n        return currentArrayOfValues;\n    } // If the checkbox was unchecked and the value is in the array, remove the value and return the array\n    return currentArrayOfValues.slice(0, index).concat(currentArrayOfValues.slice(index + 1));\n} // React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser.\n// @see https://gist.github.com/gaearon/e7d97cdf38a2907924ea12e4ebdf3c85\nvar useIsomorphicLayoutEffect =  false ? 0 : react__WEBPACK_IMPORTED_MODULE_1__.useEffect;\nfunction useEventCallback(fn) {\n    var ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(fn); // we copy a ref to the callback scoped to the current state/props on each render\n    useIsomorphicLayoutEffect(function() {\n        ref.current = fn;\n    });\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return ref.current.apply(void 0, args);\n    }, []);\n}\nfunction useField(propsOrFieldName) {\n    var formik = useFormikContext();\n    var getFieldProps = formik.getFieldProps, getFieldMeta = formik.getFieldMeta, getFieldHelpers = formik.getFieldHelpers, registerField = formik.registerField, unregisterField = formik.unregisterField;\n    var isAnObject = isObject(propsOrFieldName); // Normalize propsOrFieldName to FieldHookConfig<Val>\n    var props = isAnObject ? propsOrFieldName : {\n        name: propsOrFieldName\n    };\n    var fieldName = props.name, validateFn = props.validate;\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n        if (fieldName) {\n            registerField(fieldName, {\n                validate: validateFn\n            });\n        }\n        return function() {\n            if (fieldName) {\n                unregisterField(fieldName);\n            }\n        };\n    }, [\n        registerField,\n        unregisterField,\n        fieldName,\n        validateFn\n    ]);\n    if (true) {\n        !formik ?  true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(false, \"useField() / <Field /> must be used underneath a <Formik> component or withFormik() higher order component\") : 0 : void 0;\n    }\n    !fieldName ?  true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(false, \"Invalid field name. Either pass `useField` a string or an object containing a `name` key.\") : 0 : void 0;\n    var fieldHelpers = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(function() {\n        return getFieldHelpers(fieldName);\n    }, [\n        getFieldHelpers,\n        fieldName\n    ]);\n    return [\n        getFieldProps(props),\n        getFieldMeta(fieldName),\n        fieldHelpers\n    ];\n}\nfunction Field(_ref) {\n    var validate = _ref.validate, name = _ref.name, render = _ref.render, children = _ref.children, is = _ref.as, component = _ref.component, className = _ref.className, props = _objectWithoutPropertiesLoose(_ref, [\n        \"validate\",\n        \"name\",\n        \"render\",\n        \"children\",\n        \"as\",\n        \"component\",\n        \"className\"\n    ]);\n    var _useFormikContext = useFormikContext(), formik = _objectWithoutPropertiesLoose(_useFormikContext, [\n        \"validate\",\n        \"validationSchema\"\n    ]);\n    if (true) {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n            !!render ?  true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(false, '<Field render> has been deprecated and will be removed in future versions of Formik. Please use a child callback function instead. To get rid of this warning, replace <Field name=\"' + name + '\" render={({field, form}) => ...} /> with <Field name=\"' + name + '\">{({field, form, meta}) => ...}</Field>') : 0 : void 0;\n            !!(is && children && isFunction(children)) ?  true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(false, \"You should not use <Field as> and <Field children> as a function in the same <Field> component; <Field as> will be ignored.\") : 0 : void 0;\n            !!(component && children && isFunction(children)) ?  true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(false, \"You should not use <Field component> and <Field children> as a function in the same <Field> component; <Field component> will be ignored.\") : 0 : void 0;\n            !!(render && children && !isEmptyChildren(children)) ?  true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(false, \"You should not use <Field render> and <Field children> in the same <Field> component; <Field children> will be ignored\") : 0 : void 0; // eslint-disable-next-line\n        }, []);\n    } // Register field and field-level validation with parent <Formik>\n    var registerField = formik.registerField, unregisterField = formik.unregisterField;\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n        registerField(name, {\n            validate: validate\n        });\n        return function() {\n            unregisterField(name);\n        };\n    }, [\n        registerField,\n        unregisterField,\n        name,\n        validate\n    ]);\n    var field = formik.getFieldProps(_extends({\n        name: name\n    }, props));\n    var meta = formik.getFieldMeta(name);\n    var legacyBag = {\n        field: field,\n        form: formik\n    };\n    if (render) {\n        return render(_extends({}, legacyBag, {\n            meta: meta\n        }));\n    }\n    if (isFunction(children)) {\n        return children(_extends({}, legacyBag, {\n            meta: meta\n        }));\n    }\n    if (component) {\n        // This behavior is backwards compat with earlier Formik 0.9 to 1.x\n        if (typeof component === \"string\") {\n            var innerRef = props.innerRef, rest = _objectWithoutPropertiesLoose(props, [\n                \"innerRef\"\n            ]);\n            return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(component, _extends({\n                ref: innerRef\n            }, field, rest, {\n                className: className\n            }), children);\n        } // We don't pass `meta` for backwards compat\n        return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(component, _extends({\n            field: field,\n            form: formik\n        }, props, {\n            className: className\n        }), children);\n    } // default to input here so we can check for both `as` and `children` above\n    var asElement = is || \"input\";\n    if (typeof asElement === \"string\") {\n        var _innerRef = props.innerRef, _rest = _objectWithoutPropertiesLoose(props, [\n            \"innerRef\"\n        ]);\n        return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(asElement, _extends({\n            ref: _innerRef\n        }, field, _rest, {\n            className: className\n        }), children);\n    }\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(asElement, _extends({}, field, props, {\n        className: className\n    }), children);\n}\nvar Form = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(function(props, ref) {\n    // iOS needs an \"action\" attribute for nice input: https://stackoverflow.com/a/39485162/406725\n    // We default the action to \"#\" in case the preventDefault fails (just updates the URL hash)\n    var action = props.action, rest = _objectWithoutPropertiesLoose(props, [\n        \"action\"\n    ]);\n    var _action = action != null ? action : \"#\";\n    var _useFormikContext = useFormikContext(), handleReset = _useFormikContext.handleReset, handleSubmit = _useFormikContext.handleSubmit;\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"form\", _extends({\n        onSubmit: handleSubmit,\n        ref: ref,\n        onReset: handleReset,\n        action: _action\n    }, rest));\n});\nForm.displayName = \"Form\";\n/**\r\n * A public higher-order component to access the imperative API\r\n */ function withFormik(_ref) {\n    var _ref$mapPropsToValues = _ref.mapPropsToValues, mapPropsToValues = _ref$mapPropsToValues === void 0 ? function(vanillaProps) {\n        var val = {};\n        for(var k in vanillaProps){\n            if (vanillaProps.hasOwnProperty(k) && typeof vanillaProps[k] !== \"function\") {\n                // @todo TypeScript fix\n                val[k] = vanillaProps[k];\n            }\n        }\n        return val;\n    } : _ref$mapPropsToValues, config = _objectWithoutPropertiesLoose(_ref, [\n        \"mapPropsToValues\"\n    ]);\n    return function createFormik(Component$1) {\n        var componentDisplayName = Component$1.displayName || Component$1.name || Component$1.constructor && Component$1.constructor.name || \"Component\";\n        /**\r\n     * We need to use closures here for to provide the wrapped component's props to\r\n     * the respective withFormik config methods.\r\n     */ var C = /*#__PURE__*/ function(_React$Component) {\n            _inheritsLoose(C, _React$Component);\n            function C() {\n                var _this;\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                _this = _React$Component.call.apply(_React$Component, [\n                    this\n                ].concat(args)) || this;\n                _this.validate = function(values) {\n                    return config.validate(values, _this.props);\n                };\n                _this.validationSchema = function() {\n                    return isFunction(config.validationSchema) ? config.validationSchema(_this.props) : config.validationSchema;\n                };\n                _this.handleSubmit = function(values, actions) {\n                    return config.handleSubmit(values, _extends({}, actions, {\n                        props: _this.props\n                    }));\n                };\n                _this.renderFormComponent = function(formikProps) {\n                    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(Component$1, _extends({}, _this.props, formikProps));\n                };\n                return _this;\n            }\n            var _proto = C.prototype;\n            _proto.render = function render() {\n                var _this$props = this.props, props = _objectWithoutPropertiesLoose(_this$props, [\n                    \"children\"\n                ]);\n                return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(Formik, _extends({}, props, config, {\n                    validate: config.validate && this.validate,\n                    validationSchema: config.validationSchema && this.validationSchema,\n                    initialValues: mapPropsToValues(this.props),\n                    initialStatus: config.mapPropsToStatus && config.mapPropsToStatus(this.props),\n                    initialErrors: config.mapPropsToErrors && config.mapPropsToErrors(this.props),\n                    initialTouched: config.mapPropsToTouched && config.mapPropsToTouched(this.props),\n                    onSubmit: this.handleSubmit,\n                    children: this.renderFormComponent\n                }));\n            };\n            return C;\n        }(react__WEBPACK_IMPORTED_MODULE_1__.Component);\n        C.displayName = \"WithFormik(\" + componentDisplayName + \")\";\n        return hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_3___default()(C, Component$1 // cast type to ComponentClass (even if SFC)\n        );\n    };\n}\n/**\r\n * Connect any component to Formik context, and inject as a prop called `formik`;\r\n * @param Comp React Component\r\n */ function connect(Comp) {\n    var C = function C(props) {\n        return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(FormikConsumer, null, function(formik) {\n            !!!formik ?  true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(false, \"Formik context is undefined, please verify you are rendering <Form>, <Field>, <FastField>, <FieldArray>, or your custom context-using component as a child of a <Formik> component. Component name: \" + Comp.name) : 0 : void 0;\n            return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(Comp, _extends({}, props, {\n                formik: formik\n            }));\n        });\n    };\n    var componentDisplayName = Comp.displayName || Comp.name || Comp.constructor && Comp.constructor.name || \"Component\"; // Assign Comp to C.WrappedComponent so we can access the inner component in tests\n    // For example, <Field.WrappedComponent /> gets us <FieldInner/>\n    C.WrappedComponent = Comp;\n    C.displayName = \"FormikConnect(\" + componentDisplayName + \")\";\n    return hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_3___default()(C, Comp // cast type to ComponentClass (even if SFC)\n    );\n}\n/**\r\n * Some array helpers!\r\n */ var move = function move(array, from, to) {\n    var copy = copyArrayLike(array);\n    var value = copy[from];\n    copy.splice(from, 1);\n    copy.splice(to, 0, value);\n    return copy;\n};\nvar swap = function swap(arrayLike, indexA, indexB) {\n    var copy = copyArrayLike(arrayLike);\n    var a = copy[indexA];\n    copy[indexA] = copy[indexB];\n    copy[indexB] = a;\n    return copy;\n};\nvar insert = function insert(arrayLike, index, value) {\n    var copy = copyArrayLike(arrayLike);\n    copy.splice(index, 0, value);\n    return copy;\n};\nvar replace = function replace(arrayLike, index, value) {\n    var copy = copyArrayLike(arrayLike);\n    copy[index] = value;\n    return copy;\n};\nvar copyArrayLike = function copyArrayLike(arrayLike) {\n    if (!arrayLike) {\n        return [];\n    } else if (Array.isArray(arrayLike)) {\n        return [].concat(arrayLike);\n    } else {\n        var maxIndex = Object.keys(arrayLike).map(function(key) {\n            return parseInt(key);\n        }).reduce(function(max, el) {\n            return el > max ? el : max;\n        }, 0);\n        return Array.from(_extends({}, arrayLike, {\n            length: maxIndex + 1\n        }));\n    }\n};\nvar createAlterationHandler = function createAlterationHandler(alteration, defaultFunction) {\n    var fn = typeof alteration === \"function\" ? alteration : defaultFunction;\n    return function(data) {\n        if (Array.isArray(data) || isObject(data)) {\n            var clone = copyArrayLike(data);\n            return fn(clone);\n        } // This can be assumed to be a primitive, which\n        // is a case for top level validation errors\n        return data;\n    };\n};\nvar FieldArrayInner = /*#__PURE__*/ function(_React$Component) {\n    _inheritsLoose(FieldArrayInner, _React$Component);\n    function FieldArrayInner(props) {\n        var _this;\n        _this = _React$Component.call(this, props) || this; // We need TypeScript generics on these, so we'll bind them in the constructor\n        // @todo Fix TS 3.2.1\n        _this.updateArrayField = function(fn, alterTouched, alterErrors) {\n            var _this$props = _this.props, name = _this$props.name, setFormikState = _this$props.formik.setFormikState;\n            setFormikState(function(prevState) {\n                var updateErrors = createAlterationHandler(alterErrors, fn);\n                var updateTouched = createAlterationHandler(alterTouched, fn); // values fn should be executed before updateErrors and updateTouched,\n                // otherwise it causes an error with unshift.\n                var values = setIn(prevState.values, name, fn(getIn(prevState.values, name)));\n                var fieldError = alterErrors ? updateErrors(getIn(prevState.errors, name)) : undefined;\n                var fieldTouched = alterTouched ? updateTouched(getIn(prevState.touched, name)) : undefined;\n                if (isEmptyArray(fieldError)) {\n                    fieldError = undefined;\n                }\n                if (isEmptyArray(fieldTouched)) {\n                    fieldTouched = undefined;\n                }\n                return _extends({}, prevState, {\n                    values: values,\n                    errors: alterErrors ? setIn(prevState.errors, name, fieldError) : prevState.errors,\n                    touched: alterTouched ? setIn(prevState.touched, name, fieldTouched) : prevState.touched\n                });\n            });\n        };\n        _this.push = function(value) {\n            return _this.updateArrayField(function(arrayLike) {\n                return [].concat(copyArrayLike(arrayLike), [\n                    (0,lodash_es_cloneDeep__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(value)\n                ]);\n            }, false, false);\n        };\n        _this.handlePush = function(value) {\n            return function() {\n                return _this.push(value);\n            };\n        };\n        _this.swap = function(indexA, indexB) {\n            return _this.updateArrayField(function(array) {\n                return swap(array, indexA, indexB);\n            }, true, true);\n        };\n        _this.handleSwap = function(indexA, indexB) {\n            return function() {\n                return _this.swap(indexA, indexB);\n            };\n        };\n        _this.move = function(from, to) {\n            return _this.updateArrayField(function(array) {\n                return move(array, from, to);\n            }, true, true);\n        };\n        _this.handleMove = function(from, to) {\n            return function() {\n                return _this.move(from, to);\n            };\n        };\n        _this.insert = function(index, value) {\n            return _this.updateArrayField(function(array) {\n                return insert(array, index, value);\n            }, function(array) {\n                return insert(array, index, null);\n            }, function(array) {\n                return insert(array, index, null);\n            });\n        };\n        _this.handleInsert = function(index, value) {\n            return function() {\n                return _this.insert(index, value);\n            };\n        };\n        _this.replace = function(index, value) {\n            return _this.updateArrayField(function(array) {\n                return replace(array, index, value);\n            }, false, false);\n        };\n        _this.handleReplace = function(index, value) {\n            return function() {\n                return _this.replace(index, value);\n            };\n        };\n        _this.unshift = function(value) {\n            var length = -1;\n            _this.updateArrayField(function(array) {\n                var arr = array ? [\n                    value\n                ].concat(array) : [\n                    value\n                ];\n                length = arr.length;\n                return arr;\n            }, function(array) {\n                return array ? [\n                    null\n                ].concat(array) : [\n                    null\n                ];\n            }, function(array) {\n                return array ? [\n                    null\n                ].concat(array) : [\n                    null\n                ];\n            });\n            return length;\n        };\n        _this.handleUnshift = function(value) {\n            return function() {\n                return _this.unshift(value);\n            };\n        };\n        _this.handleRemove = function(index) {\n            return function() {\n                return _this.remove(index);\n            };\n        };\n        _this.handlePop = function() {\n            return function() {\n                return _this.pop();\n            };\n        };\n        _this.remove = _this.remove.bind(_assertThisInitialized(_this));\n        _this.pop = _this.pop.bind(_assertThisInitialized(_this));\n        return _this;\n    }\n    var _proto = FieldArrayInner.prototype;\n    _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n        if (this.props.validateOnChange && this.props.formik.validateOnChange && !react_fast_compare__WEBPACK_IMPORTED_MODULE_2___default()(getIn(prevProps.formik.values, prevProps.name), getIn(this.props.formik.values, this.props.name))) {\n            this.props.formik.validateForm(this.props.formik.values);\n        }\n    };\n    _proto.remove = function remove(index) {\n        // We need to make sure we also remove relevant pieces of `touched` and `errors`\n        var result;\n        this.updateArrayField(function(array) {\n            var copy = array ? copyArrayLike(array) : [];\n            if (!result) {\n                result = copy[index];\n            }\n            if (isFunction(copy.splice)) {\n                copy.splice(index, 1);\n            } // if the array only includes undefined values we have to return an empty array\n            return isFunction(copy.every) ? copy.every(function(v) {\n                return v === undefined;\n            }) ? [] : copy : copy;\n        }, true, true);\n        return result;\n    };\n    _proto.pop = function pop() {\n        // Remove relevant pieces of `touched` and `errors` too!\n        var result;\n        this.updateArrayField(function(array) {\n            var tmp = array.slice();\n            if (!result) {\n                result = tmp && tmp.pop && tmp.pop();\n            }\n            return tmp;\n        }, true, true);\n        return result;\n    };\n    _proto.render = function render() {\n        var arrayHelpers = {\n            push: this.push,\n            pop: this.pop,\n            swap: this.swap,\n            move: this.move,\n            insert: this.insert,\n            replace: this.replace,\n            unshift: this.unshift,\n            remove: this.remove,\n            handlePush: this.handlePush,\n            handlePop: this.handlePop,\n            handleSwap: this.handleSwap,\n            handleMove: this.handleMove,\n            handleInsert: this.handleInsert,\n            handleReplace: this.handleReplace,\n            handleUnshift: this.handleUnshift,\n            handleRemove: this.handleRemove\n        };\n        var _this$props2 = this.props, component = _this$props2.component, render = _this$props2.render, children = _this$props2.children, name = _this$props2.name, _this$props2$formik = _this$props2.formik, restOfFormik = _objectWithoutPropertiesLoose(_this$props2$formik, [\n            \"validate\",\n            \"validationSchema\"\n        ]);\n        var props = _extends({}, arrayHelpers, {\n            form: restOfFormik,\n            name: name\n        });\n        return component ? /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(component, props) : render ? render(props) : children // children come last, always called\n         ? typeof children === \"function\" ? children(props) : !isEmptyChildren(children) ? react__WEBPACK_IMPORTED_MODULE_1__.Children.only(children) : null : null;\n    };\n    return FieldArrayInner;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component);\nFieldArrayInner.defaultProps = {\n    validateOnChange: true\n};\nvar FieldArray = /*#__PURE__*/ connect(FieldArrayInner);\nvar ErrorMessageImpl = /*#__PURE__*/ function(_React$Component) {\n    _inheritsLoose(ErrorMessageImpl, _React$Component);\n    function ErrorMessageImpl() {\n        return _React$Component.apply(this, arguments) || this;\n    }\n    var _proto = ErrorMessageImpl.prototype;\n    _proto.shouldComponentUpdate = function shouldComponentUpdate(props) {\n        if (getIn(this.props.formik.errors, this.props.name) !== getIn(props.formik.errors, this.props.name) || getIn(this.props.formik.touched, this.props.name) !== getIn(props.formik.touched, this.props.name) || Object.keys(this.props).length !== Object.keys(props).length) {\n            return true;\n        } else {\n            return false;\n        }\n    };\n    _proto.render = function render() {\n        var _this$props = this.props, component = _this$props.component, formik = _this$props.formik, render = _this$props.render, children = _this$props.children, name = _this$props.name, rest = _objectWithoutPropertiesLoose(_this$props, [\n            \"component\",\n            \"formik\",\n            \"render\",\n            \"children\",\n            \"name\"\n        ]);\n        var touch = getIn(formik.touched, name);\n        var error = getIn(formik.errors, name);\n        return !!touch && !!error ? render ? isFunction(render) ? render(error) : null : children ? isFunction(children) ? children(error) : null : component ? /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(component, rest, error) : error : null;\n    };\n    return ErrorMessageImpl;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component);\nvar ErrorMessage = /*#__PURE__*/ connect(ErrorMessageImpl);\n/**\r\n * Custom Field component for quickly hooking into Formik\r\n * context and wiring up forms.\r\n */ var FastFieldInner = /*#__PURE__*/ function(_React$Component) {\n    _inheritsLoose(FastFieldInner, _React$Component);\n    function FastFieldInner(props) {\n        var _this;\n        _this = _React$Component.call(this, props) || this;\n        var render = props.render, children = props.children, component = props.component, is = props.as, name = props.name;\n        !!render ?  true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(false, \"<FastField render> has been deprecated. Please use a child callback function instead: <FastField name={\" + name + \"}>{props => ...}</FastField> instead.\") : 0 : void 0;\n        !!(component && render) ?  true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(false, \"You should not use <FastField component> and <FastField render> in the same <FastField> component; <FastField component> will be ignored\") : 0 : void 0;\n        !!(is && children && isFunction(children)) ?  true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(false, \"You should not use <FastField as> and <FastField children> as a function in the same <FastField> component; <FastField as> will be ignored.\") : 0 : void 0;\n        !!(component && children && isFunction(children)) ?  true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(false, \"You should not use <FastField component> and <FastField children> as a function in the same <FastField> component; <FastField component> will be ignored.\") : 0 : void 0;\n        !!(render && children && !isEmptyChildren(children)) ?  true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(false, \"You should not use <FastField render> and <FastField children> in the same <FastField> component; <FastField children> will be ignored\") : 0 : void 0;\n        return _this;\n    }\n    var _proto = FastFieldInner.prototype;\n    _proto.shouldComponentUpdate = function shouldComponentUpdate(props) {\n        if (this.props.shouldUpdate) {\n            return this.props.shouldUpdate(props, this.props);\n        } else if (props.name !== this.props.name || getIn(props.formik.values, this.props.name) !== getIn(this.props.formik.values, this.props.name) || getIn(props.formik.errors, this.props.name) !== getIn(this.props.formik.errors, this.props.name) || getIn(props.formik.touched, this.props.name) !== getIn(this.props.formik.touched, this.props.name) || Object.keys(this.props).length !== Object.keys(props).length || props.formik.isSubmitting !== this.props.formik.isSubmitting) {\n            return true;\n        } else {\n            return false;\n        }\n    };\n    _proto.componentDidMount = function componentDidMount() {\n        // Register the Field with the parent Formik. Parent will cycle through\n        // registered Field's validate fns right prior to submit\n        this.props.formik.registerField(this.props.name, {\n            validate: this.props.validate\n        });\n    };\n    _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n        if (this.props.name !== prevProps.name) {\n            this.props.formik.unregisterField(prevProps.name);\n            this.props.formik.registerField(this.props.name, {\n                validate: this.props.validate\n            });\n        }\n        if (this.props.validate !== prevProps.validate) {\n            this.props.formik.registerField(this.props.name, {\n                validate: this.props.validate\n            });\n        }\n    };\n    _proto.componentWillUnmount = function componentWillUnmount() {\n        this.props.formik.unregisterField(this.props.name);\n    };\n    _proto.render = function render() {\n        var _this$props = this.props, name = _this$props.name, render = _this$props.render, is = _this$props.as, children = _this$props.children, component = _this$props.component, formik = _this$props.formik, props = _objectWithoutPropertiesLoose(_this$props, [\n            \"validate\",\n            \"name\",\n            \"render\",\n            \"as\",\n            \"children\",\n            \"component\",\n            \"shouldUpdate\",\n            \"formik\"\n        ]);\n        var restOfFormik = _objectWithoutPropertiesLoose(formik, [\n            \"validate\",\n            \"validationSchema\"\n        ]);\n        var field = formik.getFieldProps(_extends({\n            name: name\n        }, props));\n        var meta = {\n            value: getIn(formik.values, name),\n            error: getIn(formik.errors, name),\n            touched: !!getIn(formik.touched, name),\n            initialValue: getIn(formik.initialValues, name),\n            initialTouched: !!getIn(formik.initialTouched, name),\n            initialError: getIn(formik.initialErrors, name)\n        };\n        var bag = {\n            field: field,\n            meta: meta,\n            form: restOfFormik\n        };\n        if (render) {\n            return render(bag);\n        }\n        if (isFunction(children)) {\n            return children(bag);\n        }\n        if (component) {\n            // This behavior is backwards compat with earlier Formik 0.9 to 1.x\n            if (typeof component === \"string\") {\n                var innerRef = props.innerRef, rest = _objectWithoutPropertiesLoose(props, [\n                    \"innerRef\"\n                ]);\n                return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(component, _extends({\n                    ref: innerRef\n                }, field, rest), children);\n            } // We don't pass `meta` for backwards compat\n            return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(component, _extends({\n                field: field,\n                form: formik\n            }, props), children);\n        } // default to input here so we can check for both `as` and `children` above\n        var asElement = is || \"input\";\n        if (typeof asElement === \"string\") {\n            var _innerRef = props.innerRef, _rest = _objectWithoutPropertiesLoose(props, [\n                \"innerRef\"\n            ]);\n            return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(asElement, _extends({\n                ref: _innerRef\n            }, field, _rest), children);\n        }\n        return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(asElement, _extends({}, field, props), children);\n    };\n    return FastFieldInner;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component);\nvar FastField = /*#__PURE__*/ connect(FastFieldInner);\n //# sourceMappingURL=formik.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2Zvcm1pay9kaXN0L2Zvcm1pay5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFrQztBQUNrQjtBQUN1STtBQUNsSjtBQUNKO0FBQ0Q7QUFDRTtBQUNxQjtBQUNmO0FBRTVDLFNBQVNxQjtJQUNQQSxXQUFXQyxPQUFPQyxNQUFNLElBQUksU0FBVUMsTUFBTTtRQUMxQyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUMsVUFBVUMsTUFBTSxFQUFFRixJQUFLO1lBQ3pDLElBQUlHLFNBQVNGLFNBQVMsQ0FBQ0QsRUFBRTtZQUV6QixJQUFLLElBQUlJLE9BQU9ELE9BQVE7Z0JBQ3RCLElBQUlOLE9BQU9RLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNKLFFBQVFDLE1BQU07b0JBQ3JETCxNQUFNLENBQUNLLElBQUksR0FBR0QsTUFBTSxDQUFDQyxJQUFJO2dCQUMzQjtZQUNGO1FBQ0Y7UUFFQSxPQUFPTDtJQUNUO0lBRUEsT0FBT0gsU0FBU1ksS0FBSyxDQUFDLElBQUksRUFBRVA7QUFDOUI7QUFFQSxTQUFTUSxlQUFlQyxRQUFRLEVBQUVDLFVBQVU7SUFDMUNELFNBQVNMLFNBQVMsR0FBR1IsT0FBT2UsTUFBTSxDQUFDRCxXQUFXTixTQUFTO0lBQ3ZESyxTQUFTTCxTQUFTLENBQUNRLFdBQVcsR0FBR0g7SUFDakNBLFNBQVNJLFNBQVMsR0FBR0g7QUFDdkI7QUFFQSxTQUFTSSw4QkFBOEJaLE1BQU0sRUFBRWEsUUFBUTtJQUNyRCxJQUFJYixVQUFVLE1BQU0sT0FBTyxDQUFDO0lBQzVCLElBQUlKLFNBQVMsQ0FBQztJQUNkLElBQUlrQixhQUFhcEIsT0FBT3FCLElBQUksQ0FBQ2Y7SUFDN0IsSUFBSUMsS0FBS0o7SUFFVCxJQUFLQSxJQUFJLEdBQUdBLElBQUlpQixXQUFXZixNQUFNLEVBQUVGLElBQUs7UUFDdENJLE1BQU1hLFVBQVUs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bEI7UUFFQSxJQUFJN0ksV0FBVztZQUNiLG1FQUFtRTtZQUNuRSxJQUFJLE9BQU9BLGNBQWMsVUFBVTtnQkFDakMsSUFBSUUsV0FBV2hKLE1BQU1nSixRQUFRLEVBQ3pCakosT0FBT2hHLDhCQUE4QmlHLE9BQU87b0JBQUM7aUJBQVc7Z0JBRTVELHFCQUFPOUgsb0RBQWFBLENBQUM0USxXQUFXbFEsU0FBUztvQkFDdkN5UyxLQUFLckM7Z0JBQ1AsR0FBR2pLLE9BQU9nQixPQUFPN0Q7WUFDbkIsRUFBRSw0Q0FBNEM7WUFHOUMscUJBQU9oRSxvREFBYUEsQ0FBQzRRLFdBQVdsUSxTQUFTO2dCQUN2Q21HLE9BQU9BO2dCQUNQb04sTUFBTXBSO1lBQ1IsR0FBR2lGLFFBQVE5RDtRQUNiLEVBQUUsMkVBQTJFO1FBRzdFLElBQUlrUSxZQUFZN0QsTUFBTTtRQUV0QixJQUFJLE9BQU82RCxjQUFjLFVBQVU7WUFDakMsSUFBSUMsWUFBWXJNLE1BQU1nSixRQUFRLEVBQzFCc0QsUUFBUXZTLDhCQUE4QmlHLE9BQU87Z0JBQUM7YUFBVztZQUU3RCxxQkFBTzlILG9EQUFhQSxDQUFDa1UsV0FBV3hULFNBQVM7Z0JBQ3ZDeVMsS0FBS2dCO1lBQ1AsR0FBR3ROLE9BQU91TixRQUFRcFE7UUFDcEI7UUFFQSxxQkFBT2hFLG9EQUFhQSxDQUFDa1UsV0FBV3hULFNBQVMsQ0FBQyxHQUFHbUcsT0FBT2lCLFFBQVE5RDtJQUM5RDtJQUVBLE9BQU9xVjtBQUNULEVBQUVsWiw0Q0FBU0E7QUFFWCxJQUFJdVosWUFBWSxXQUFXLEdBQUVoRSxRQUFRMkQ7QUFFaVosQ0FDdGIsc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL2Zvcm1pay9kaXN0L2Zvcm1pay5lc20uanM/MTBiZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZGVlcG1lcmdlIGZyb20gJ2RlZXBtZXJnZSc7XG5pbXBvcnQgaXNQbGFpbk9iamVjdCBmcm9tICdsb2Rhc2gtZXMvaXNQbGFpbk9iamVjdCc7XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCBDaGlsZHJlbiwgdXNlUmVmLCB1c2VFZmZlY3QsIHVzZVN0YXRlLCB1c2VDYWxsYmFjaywgdXNlTWVtbywgdXNlSW1wZXJhdGl2ZUhhbmRsZSwgY3JlYXRlRWxlbWVudCwgdXNlTGF5b3V0RWZmZWN0LCBmb3J3YXJkUmVmLCBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgaXNFcXVhbCBmcm9tICdyZWFjdC1mYXN0LWNvbXBhcmUnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICd0aW55LXdhcm5pbmcnO1xuaW1wb3J0IGNsb25lIGZyb20gJ2xvZGFzaC1lcy9jbG9uZSc7XG5pbXBvcnQgdG9QYXRoIGZyb20gJ2xvZGFzaC1lcy90b1BhdGgnO1xuaW1wb3J0IGhvaXN0Tm9uUmVhY3RTdGF0aWNzIGZyb20gJ2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzJztcbmltcG9ydCBjbG9uZURlZXAgZnJvbSAnbG9kYXNoLWVzL2Nsb25lRGVlcCc7XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG5cbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbnZhciBGb3JtaWtDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQodW5kZWZpbmVkKTtcbkZvcm1pa0NvbnRleHQuZGlzcGxheU5hbWUgPSAnRm9ybWlrQ29udGV4dCc7XG52YXIgRm9ybWlrUHJvdmlkZXIgPSBGb3JtaWtDb250ZXh0LlByb3ZpZGVyO1xudmFyIEZvcm1pa0NvbnN1bWVyID0gRm9ybWlrQ29udGV4dC5Db25zdW1lcjtcbmZ1bmN0aW9uIHVzZUZvcm1pa0NvbnRleHQoKSB7XG4gIHZhciBmb3JtaWsgPSB1c2VDb250ZXh0KEZvcm1pa0NvbnRleHQpO1xuICAhISFmb3JtaWsgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiRm9ybWlrIGNvbnRleHQgaXMgdW5kZWZpbmVkLCBwbGVhc2UgdmVyaWZ5IHlvdSBhcmUgY2FsbGluZyB1c2VGb3JtaWtDb250ZXh0KCkgYXMgY2hpbGQgb2YgYSA8Rm9ybWlrPiBjb21wb25lbnQuXCIpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGZvcm1paztcbn1cblxuLyoqIEBwcml2YXRlIGlzIHRoZSB2YWx1ZSBhbiBlbXB0eSBhcnJheT8gKi9cblxudmFyIGlzRW1wdHlBcnJheSA9IGZ1bmN0aW9uIGlzRW1wdHlBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAwO1xufTtcbi8qKiBAcHJpdmF0ZSBpcyB0aGUgZ2l2ZW4gb2JqZWN0IGEgRnVuY3Rpb24/ICovXG5cbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbic7XG59O1xuLyoqIEBwcml2YXRlIGlzIHRoZSBnaXZlbiBvYmplY3QgYW4gT2JqZWN0PyAqL1xuXG52YXIgaXNPYmplY3QgPSBmdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jztcbn07XG4vKiogQHByaXZhdGUgaXMgdGhlIGdpdmVuIG9iamVjdCBhbiBpbnRlZ2VyPyAqL1xuXG52YXIgaXNJbnRlZ2VyID0gZnVuY3Rpb24gaXNJbnRlZ2VyKG9iaikge1xuICByZXR1cm4gU3RyaW5nKE1hdGguZmxvb3IoTnVtYmVyKG9iaikpKSA9PT0gb2JqO1xufTtcbi8qKiBAcHJpdmF0ZSBpcyB0aGUgZ2l2ZW4gb2JqZWN0IGEgc3RyaW5nPyAqL1xuXG52YXIgaXNTdHJpbmcgPSBmdW5jdGlvbiBpc1N0cmluZyhvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBTdHJpbmddJztcbn07XG4vKiogQHByaXZhdGUgaXMgdGhlIGdpdmVuIG9iamVjdCBhIE5hTj8gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcblxudmFyIGlzTmFOJDEgPSBmdW5jdGlvbiBpc05hTihvYmopIHtcbiAgcmV0dXJuIG9iaiAhPT0gb2JqO1xufTtcbi8qKiBAcHJpdmF0ZSBEb2VzIGEgUmVhY3QgY29tcG9uZW50IGhhdmUgZXhhY3RseSAwIGNoaWxkcmVuPyAqL1xuXG52YXIgaXNFbXB0eUNoaWxkcmVuID0gZnVuY3Rpb24gaXNFbXB0eUNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIHJldHVybiBDaGlsZHJlbi5jb3VudChjaGlsZHJlbikgPT09IDA7XG59O1xuLyoqIEBwcml2YXRlIGlzIHRoZSBnaXZlbiBvYmplY3QvdmFsdWUgYSBwcm9taXNlPyAqL1xuXG52YXIgaXNQcm9taXNlID0gZnVuY3Rpb24gaXNQcm9taXNlKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgaXNGdW5jdGlvbih2YWx1ZS50aGVuKTtcbn07XG4vKiogQHByaXZhdGUgaXMgdGhlIGdpdmVuIG9iamVjdC92YWx1ZSBhIHR5cGUgb2Ygc3ludGhldGljIGV2ZW50PyAqL1xuXG52YXIgaXNJbnB1dEV2ZW50ID0gZnVuY3Rpb24gaXNJbnB1dEV2ZW50KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAmJiBpc09iamVjdCh2YWx1ZSkgJiYgaXNPYmplY3QodmFsdWUudGFyZ2V0KTtcbn07XG4vKipcclxuICogU2FtZSBhcyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGJ1dCB3cmFwcyBpbiBhIHRyeS1jYXRjaCBibG9jay4gSW4gSUUgaXQgaXNcclxuICogbm90IHNhZmUgdG8gY2FsbCBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGlmIHRoZXJlIGlzIG5vdGhpbmcgZm9jdXNlZC5cclxuICpcclxuICogVGhlIGFjdGl2ZUVsZW1lbnQgd2lsbCBiZSBudWxsIG9ubHkgaWYgdGhlIGRvY3VtZW50IG9yIGRvY3VtZW50IGJvZHkgaXMgbm90XHJcbiAqIHlldCBkZWZpbmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0gez9Eb2N1bWVudH0gZG9jIERlZmF1bHRzIHRvIGN1cnJlbnQgZG9jdW1lbnQuXHJcbiAqIEByZXR1cm4ge0VsZW1lbnQgfCBudWxsfVxyXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mYmpzL2Jsb2IvbWFzdGVyL3BhY2thZ2VzL2ZianMvc3JjL2NvcmUvZG9tL2dldEFjdGl2ZUVsZW1lbnQuanNcclxuICovXG5cbmZ1bmN0aW9uIGdldEFjdGl2ZUVsZW1lbnQoZG9jKSB7XG4gIGRvYyA9IGRvYyB8fCAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50IDogdW5kZWZpbmVkKTtcblxuICBpZiAodHlwZW9mIGRvYyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGRvYy5hY3RpdmVFbGVtZW50IHx8IGRvYy5ib2R5O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGRvYy5ib2R5O1xuICB9XG59XG4vKipcclxuICogRGVlcGx5IGdldCBhIHZhbHVlIGZyb20gYW4gb2JqZWN0IHZpYSBpdHMgcGF0aC5cclxuICovXG5cbmZ1bmN0aW9uIGdldEluKG9iaiwga2V5LCBkZWYsIHApIHtcbiAgaWYgKHAgPT09IHZvaWQgMCkge1xuICAgIHAgPSAwO1xuICB9XG5cbiAgdmFyIHBhdGggPSB0b1BhdGgoa2V5KTtcblxuICB3aGlsZSAob2JqICYmIHAgPCBwYXRoLmxlbmd0aCkge1xuICAgIG9iaiA9IG9ialtwYXRoW3ArK11dO1xuICB9IC8vIGNoZWNrIGlmIHBhdGggaXMgbm90IGluIHRoZSBlbmRcblxuXG4gIGlmIChwICE9PSBwYXRoLmxlbmd0aCAmJiAhb2JqKSB7XG4gICAgcmV0dXJuIGRlZjtcbiAgfVxuXG4gIHJldHVybiBvYmogPT09IHVuZGVmaW5lZCA/IGRlZiA6IG9iajtcbn1cbi8qKlxyXG4gKiBEZWVwbHkgc2V0IGEgdmFsdWUgZnJvbSBpbiBvYmplY3QgdmlhIGl0J3MgcGF0aC4gSWYgdGhlIHZhbHVlIGF0IGBwYXRoYFxyXG4gKiBoYXMgY2hhbmdlZCwgcmV0dXJuIGEgc2hhbGxvdyBjb3B5IG9mIG9iaiB3aXRoIGB2YWx1ZWAgc2V0IGF0IGBwYXRoYC5cclxuICogSWYgYHZhbHVlYCBoYXMgbm90IGNoYW5nZWQsIHJldHVybiB0aGUgb3JpZ2luYWwgYG9iamAuXHJcbiAqXHJcbiAqIEV4aXN0aW5nIG9iamVjdHMgLyBhcnJheXMgYWxvbmcgYHBhdGhgIGFyZSBhbHNvIHNoYWxsb3cgY29waWVkLiBTaWJsaW5nXHJcbiAqIG9iamVjdHMgYWxvbmcgcGF0aCByZXRhaW4gdGhlIHNhbWUgaW50ZXJuYWwganMgcmVmZXJlbmNlLiBTaW5jZSBuZXdcclxuICogb2JqZWN0cyAvIGFycmF5cyBhcmUgb25seSBjcmVhdGVkIGFsb25nIGBwYXRoYCwgd2UgY2FuIHRlc3QgaWYgYW55dGhpbmdcclxuICogY2hhbmdlZCBpbiBhIG5lc3RlZCBzdHJ1Y3R1cmUgYnkgY29tcGFyaW5nIHRoZSBvYmplY3QncyByZWZlcmVuY2UgaW5cclxuICogdGhlIG9sZCBhbmQgbmV3IG9iamVjdCwgc2ltaWxhciB0byBob3cgcnVzc2lhbiBkb2xsIGNhY2hlIGludmFsaWRhdGlvblxyXG4gKiB3b3Jrcy5cclxuICpcclxuICogSW4gZWFybGllciB2ZXJzaW9ucyBvZiB0aGlzIGZ1bmN0aW9uLCB3aGljaCB1c2VkIGNsb25lRGVlcCwgdGhlcmUgd2VyZVxyXG4gKiBpc3N1ZXMgd2hlcmVieSBzZXR0aW5ncyBhIG5lc3RlZCB2YWx1ZSB3b3VsZCBtdXRhdGUgdGhlIHBhcmVudFxyXG4gKiBpbnN0ZWFkIG9mIGNyZWF0aW5nIGEgbmV3IG9iamVjdC4gYGNsb25lYCBhdm9pZHMgdGhhdCBidWcgbWFraW5nIGFcclxuICogc2hhbGxvdyBjb3B5IG9mIHRoZSBvYmplY3RzIGFsb25nIHRoZSB1cGRhdGUgcGF0aFxyXG4gKiBzbyBubyBvYmplY3QgaXMgbXV0YXRlZCBpbiBwbGFjZS5cclxuICpcclxuICogQmVmb3JlIGNoYW5naW5nIHRoaXMgZnVuY3Rpb24sIHBsZWFzZSByZWFkIHRocm91Z2ggdGhlIGZvbGxvd2luZ1xyXG4gKiBkaXNjdXNzaW9ucy5cclxuICpcclxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vZGV2ZWxvcGl0L2xpbmtzdGF0ZVxyXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXJlZHBhbG1lci9mb3JtaWsvcHVsbC8xMjNcclxuICovXG5cbmZ1bmN0aW9uIHNldEluKG9iaiwgcGF0aCwgdmFsdWUpIHtcbiAgdmFyIHJlcyA9IGNsb25lKG9iaik7IC8vIHRoaXMga2VlcHMgaW5oZXJpdGFuY2Ugd2hlbiBvYmogaXMgYSBjbGFzc1xuXG4gIHZhciByZXNWYWwgPSByZXM7XG4gIHZhciBpID0gMDtcbiAgdmFyIHBhdGhBcnJheSA9IHRvUGF0aChwYXRoKTtcblxuICBmb3IgKDsgaSA8IHBhdGhBcnJheS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICB2YXIgY3VycmVudFBhdGggPSBwYXRoQXJyYXlbaV07XG4gICAgdmFyIGN1cnJlbnRPYmogPSBnZXRJbihvYmosIHBhdGhBcnJheS5zbGljZSgwLCBpICsgMSkpO1xuXG4gICAgaWYgKGN1cnJlbnRPYmogJiYgKGlzT2JqZWN0KGN1cnJlbnRPYmopIHx8IEFycmF5LmlzQXJyYXkoY3VycmVudE9iaikpKSB7XG4gICAgICByZXNWYWwgPSByZXNWYWxbY3VycmVudFBhdGhdID0gY2xvbmUoY3VycmVudE9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBuZXh0UGF0aCA9IHBhdGhBcnJheVtpICsgMV07XG4gICAgICByZXNWYWwgPSByZXNWYWxbY3VycmVudFBhdGhdID0gaXNJbnRlZ2VyKG5leHRQYXRoKSAmJiBOdW1iZXIobmV4dFBhdGgpID49IDAgPyBbXSA6IHt9O1xuICAgIH1cbiAgfSAvLyBSZXR1cm4gb3JpZ2luYWwgb2JqZWN0IGlmIG5ldyB2YWx1ZSBpcyB0aGUgc2FtZSBhcyBjdXJyZW50XG5cblxuICBpZiAoKGkgPT09IDAgPyBvYmogOiByZXNWYWwpW3BhdGhBcnJheVtpXV0gPT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZGVsZXRlIHJlc1ZhbFtwYXRoQXJyYXlbaV1dO1xuICB9IGVsc2Uge1xuICAgIHJlc1ZhbFtwYXRoQXJyYXlbaV1dID0gdmFsdWU7XG4gIH0gLy8gSWYgdGhlIHBhdGggYXJyYXkgaGFzIGEgc2luZ2xlIGVsZW1lbnQsIHRoZSBsb29wIGRpZCBub3QgcnVuLlxuICAvLyBEZWxldGluZyBvbiBgcmVzVmFsYCBoYWQgbm8gZWZmZWN0IGluIHRoaXMgc2NlbmFyaW8sIHNvIHdlIGRlbGV0ZSBvbiB0aGUgcmVzdWx0IGluc3RlYWQuXG5cblxuICBpZiAoaSA9PT0gMCAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZGVsZXRlIHJlc1twYXRoQXJyYXlbaV1dO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn1cbi8qKlxyXG4gKiBSZWN1cnNpdmVseSBhIHNldCB0aGUgc2FtZSB2YWx1ZSBmb3IgYWxsIGtleXMgYW5kIGFycmF5cyBuZXN0ZWQgb2JqZWN0LCBjbG9uaW5nXHJcbiAqIEBwYXJhbSBvYmplY3RcclxuICogQHBhcmFtIHZhbHVlXHJcbiAqIEBwYXJhbSB2aXNpdGVkXHJcbiAqIEBwYXJhbSByZXNwb25zZVxyXG4gKi9cblxuZnVuY3Rpb24gc2V0TmVzdGVkT2JqZWN0VmFsdWVzKG9iamVjdCwgdmFsdWUsIHZpc2l0ZWQsIHJlc3BvbnNlKSB7XG4gIGlmICh2aXNpdGVkID09PSB2b2lkIDApIHtcbiAgICB2aXNpdGVkID0gbmV3IFdlYWtNYXAoKTtcbiAgfVxuXG4gIGlmIChyZXNwb25zZSA9PT0gdm9pZCAwKSB7XG4gICAgcmVzcG9uc2UgPSB7fTtcbiAgfVxuXG4gIGZvciAodmFyIF9pID0gMCwgX09iamVjdCRrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgX2kgPCBfT2JqZWN0JGtleXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgdmFyIGsgPSBfT2JqZWN0JGtleXNbX2ldO1xuICAgIHZhciB2YWwgPSBvYmplY3Rba107XG5cbiAgICBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgICAgaWYgKCF2aXNpdGVkLmdldCh2YWwpKSB7XG4gICAgICAgIHZpc2l0ZWQuc2V0KHZhbCwgdHJ1ZSk7IC8vIEluIG9yZGVyIHRvIGtlZXAgYXJyYXkgdmFsdWVzIGNvbnNpc3RlbnQgZm9yIGJvdGggZG90IHBhdGggIGFuZFxuICAgICAgICAvLyBicmFja2V0IHN5bnRheCwgd2UgbmVlZCB0byBjaGVjayBpZiB0aGlzIGlzIGFuIGFycmF5IHNvIHRoYXRcbiAgICAgICAgLy8gdGhpcyB3aWxsIG91dHB1dCAgeyBmcmllbmRzOiBbdHJ1ZV0gfSBhbmQgbm90IHsgZnJpZW5kczogeyBcIjBcIjogdHJ1ZSB9IH1cblxuICAgICAgICByZXNwb25zZVtrXSA9IEFycmF5LmlzQXJyYXkodmFsKSA/IFtdIDoge307XG4gICAgICAgIHNldE5lc3RlZE9iamVjdFZhbHVlcyh2YWwsIHZhbHVlLCB2aXNpdGVkLCByZXNwb25zZVtrXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3BvbnNlW2tdID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3BvbnNlO1xufVxuXG5mdW5jdGlvbiBmb3JtaWtSZWR1Y2VyKHN0YXRlLCBtc2cpIHtcbiAgc3dpdGNoIChtc2cudHlwZSkge1xuICAgIGNhc2UgJ1NFVF9WQUxVRVMnOlxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICB2YWx1ZXM6IG1zZy5wYXlsb2FkXG4gICAgICB9KTtcblxuICAgIGNhc2UgJ1NFVF9UT1VDSEVEJzpcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgdG91Y2hlZDogbXNnLnBheWxvYWRcbiAgICAgIH0pO1xuXG4gICAgY2FzZSAnU0VUX0VSUk9SUyc6XG4gICAgICBpZiAoaXNFcXVhbChzdGF0ZS5lcnJvcnMsIG1zZy5wYXlsb2FkKSkge1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgZXJyb3JzOiBtc2cucGF5bG9hZFxuICAgICAgfSk7XG5cbiAgICBjYXNlICdTRVRfU1RBVFVTJzpcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgc3RhdHVzOiBtc2cucGF5bG9hZFxuICAgICAgfSk7XG5cbiAgICBjYXNlICdTRVRfSVNTVUJNSVRUSU5HJzpcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgaXNTdWJtaXR0aW5nOiBtc2cucGF5bG9hZFxuICAgICAgfSk7XG5cbiAgICBjYXNlICdTRVRfSVNWQUxJREFUSU5HJzpcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgaXNWYWxpZGF0aW5nOiBtc2cucGF5bG9hZFxuICAgICAgfSk7XG5cbiAgICBjYXNlICdTRVRfRklFTERfVkFMVUUnOlxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICB2YWx1ZXM6IHNldEluKHN0YXRlLnZhbHVlcywgbXNnLnBheWxvYWQuZmllbGQsIG1zZy5wYXlsb2FkLnZhbHVlKVxuICAgICAgfSk7XG5cbiAgICBjYXNlICdTRVRfRklFTERfVE9VQ0hFRCc6XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIHRvdWNoZWQ6IHNldEluKHN0YXRlLnRvdWNoZWQsIG1zZy5wYXlsb2FkLmZpZWxkLCBtc2cucGF5bG9hZC52YWx1ZSlcbiAgICAgIH0pO1xuXG4gICAgY2FzZSAnU0VUX0ZJRUxEX0VSUk9SJzpcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgZXJyb3JzOiBzZXRJbihzdGF0ZS5lcnJvcnMsIG1zZy5wYXlsb2FkLmZpZWxkLCBtc2cucGF5bG9hZC52YWx1ZSlcbiAgICAgIH0pO1xuXG4gICAgY2FzZSAnUkVTRVRfRk9STSc6XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCBtc2cucGF5bG9hZCk7XG5cbiAgICBjYXNlICdTRVRfRk9STUlLX1NUQVRFJzpcbiAgICAgIHJldHVybiBtc2cucGF5bG9hZChzdGF0ZSk7XG5cbiAgICBjYXNlICdTVUJNSVRfQVRURU1QVCc6XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIHRvdWNoZWQ6IHNldE5lc3RlZE9iamVjdFZhbHVlcyhzdGF0ZS52YWx1ZXMsIHRydWUpLFxuICAgICAgICBpc1N1Ym1pdHRpbmc6IHRydWUsXG4gICAgICAgIHN1Ym1pdENvdW50OiBzdGF0ZS5zdWJtaXRDb3VudCArIDFcbiAgICAgIH0pO1xuXG4gICAgY2FzZSAnU1VCTUlUX0ZBSUxVUkUnOlxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICBpc1N1Ym1pdHRpbmc6IGZhbHNlXG4gICAgICB9KTtcblxuICAgIGNhc2UgJ1NVQk1JVF9TVUNDRVNTJzpcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgaXNTdWJtaXR0aW5nOiBmYWxzZVxuICAgICAgfSk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9XG59IC8vIEluaXRpYWwgZW1wdHkgc3RhdGVzIC8vIG9iamVjdHNcblxuXG52YXIgZW1wdHlFcnJvcnMgPSB7fTtcbnZhciBlbXB0eVRvdWNoZWQgPSB7fTtcbmZ1bmN0aW9uIHVzZUZvcm1payhfcmVmKSB7XG4gIHZhciBfcmVmJHZhbGlkYXRlT25DaGFuZ2UgPSBfcmVmLnZhbGlkYXRlT25DaGFuZ2UsXG4gICAgICB2YWxpZGF0ZU9uQ2hhbmdlID0gX3JlZiR2YWxpZGF0ZU9uQ2hhbmdlID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZiR2YWxpZGF0ZU9uQ2hhbmdlLFxuICAgICAgX3JlZiR2YWxpZGF0ZU9uQmx1ciA9IF9yZWYudmFsaWRhdGVPbkJsdXIsXG4gICAgICB2YWxpZGF0ZU9uQmx1ciA9IF9yZWYkdmFsaWRhdGVPbkJsdXIgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmJHZhbGlkYXRlT25CbHVyLFxuICAgICAgX3JlZiR2YWxpZGF0ZU9uTW91bnQgPSBfcmVmLnZhbGlkYXRlT25Nb3VudCxcbiAgICAgIHZhbGlkYXRlT25Nb3VudCA9IF9yZWYkdmFsaWRhdGVPbk1vdW50ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkdmFsaWRhdGVPbk1vdW50LFxuICAgICAgaXNJbml0aWFsVmFsaWQgPSBfcmVmLmlzSW5pdGlhbFZhbGlkLFxuICAgICAgX3JlZiRlbmFibGVSZWluaXRpYWxpID0gX3JlZi5lbmFibGVSZWluaXRpYWxpemUsXG4gICAgICBlbmFibGVSZWluaXRpYWxpemUgPSBfcmVmJGVuYWJsZVJlaW5pdGlhbGkgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRlbmFibGVSZWluaXRpYWxpLFxuICAgICAgb25TdWJtaXQgPSBfcmVmLm9uU3VibWl0LFxuICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIFtcInZhbGlkYXRlT25DaGFuZ2VcIiwgXCJ2YWxpZGF0ZU9uQmx1clwiLCBcInZhbGlkYXRlT25Nb3VudFwiLCBcImlzSW5pdGlhbFZhbGlkXCIsIFwiZW5hYmxlUmVpbml0aWFsaXplXCIsIFwib25TdWJtaXRcIl0pO1xuXG4gIHZhciBwcm9wcyA9IF9leHRlbmRzKHtcbiAgICB2YWxpZGF0ZU9uQ2hhbmdlOiB2YWxpZGF0ZU9uQ2hhbmdlLFxuICAgIHZhbGlkYXRlT25CbHVyOiB2YWxpZGF0ZU9uQmx1cixcbiAgICB2YWxpZGF0ZU9uTW91bnQ6IHZhbGlkYXRlT25Nb3VudCxcbiAgICBvblN1Ym1pdDogb25TdWJtaXRcbiAgfSwgcmVzdCk7XG5cbiAgdmFyIGluaXRpYWxWYWx1ZXMgPSB1c2VSZWYocHJvcHMuaW5pdGlhbFZhbHVlcyk7XG4gIHZhciBpbml0aWFsRXJyb3JzID0gdXNlUmVmKHByb3BzLmluaXRpYWxFcnJvcnMgfHwgZW1wdHlFcnJvcnMpO1xuICB2YXIgaW5pdGlhbFRvdWNoZWQgPSB1c2VSZWYocHJvcHMuaW5pdGlhbFRvdWNoZWQgfHwgZW1wdHlUb3VjaGVkKTtcbiAgdmFyIGluaXRpYWxTdGF0dXMgPSB1c2VSZWYocHJvcHMuaW5pdGlhbFN0YXR1cyk7XG4gIHZhciBpc01vdW50ZWQgPSB1c2VSZWYoZmFsc2UpO1xuICB2YXIgZmllbGRSZWdpc3RyeSA9IHVzZVJlZih7fSk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAhKHR5cGVvZiBpc0luaXRpYWxWYWxpZCA9PT0gJ3VuZGVmaW5lZCcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnaXNJbml0aWFsVmFsaWQgaGFzIGJlZW4gZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGZ1dHVyZSB2ZXJzaW9ucyBvZiBGb3JtaWsuIFBsZWFzZSB1c2UgaW5pdGlhbEVycm9ycyBvciB2YWxpZGF0ZU9uTW91bnQgaW5zdGVhZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIH0sIFtdKTtcbiAgfVxuXG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaXNNb3VudGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpc01vdW50ZWQuY3VycmVudCA9IGZhbHNlO1xuICAgIH07XG4gIH0sIFtdKTtcblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlID0gdXNlU3RhdGUoMCksXG4gICAgICBzZXRJdGVyYXRpb24gPSBfUmVhY3QkdXNlU3RhdGVbMV07XG5cbiAgdmFyIHN0YXRlUmVmID0gdXNlUmVmKHtcbiAgICB2YWx1ZXM6IHByb3BzLmluaXRpYWxWYWx1ZXMsXG4gICAgZXJyb3JzOiBwcm9wcy5pbml0aWFsRXJyb3JzIHx8IGVtcHR5RXJyb3JzLFxuICAgIHRvdWNoZWQ6IHByb3BzLmluaXRpYWxUb3VjaGVkIHx8IGVtcHR5VG91Y2hlZCxcbiAgICBzdGF0dXM6IHByb3BzLmluaXRpYWxTdGF0dXMsXG4gICAgaXNTdWJtaXR0aW5nOiBmYWxzZSxcbiAgICBpc1ZhbGlkYXRpbmc6IGZhbHNlLFxuICAgIHN1Ym1pdENvdW50OiAwXG4gIH0pO1xuICB2YXIgc3RhdGUgPSBzdGF0ZVJlZi5jdXJyZW50O1xuICB2YXIgZGlzcGF0Y2ggPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgdmFyIHByZXYgPSBzdGF0ZVJlZi5jdXJyZW50O1xuICAgIHN0YXRlUmVmLmN1cnJlbnQgPSBmb3JtaWtSZWR1Y2VyKHByZXYsIGFjdGlvbik7IC8vIGZvcmNlIHJlcmVuZGVyXG5cbiAgICBpZiAocHJldiAhPT0gc3RhdGVSZWYuY3VycmVudCkgc2V0SXRlcmF0aW9uKGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geCArIDE7XG4gICAgfSk7XG4gIH0sIFtdKTtcbiAgdmFyIHJ1blZhbGlkYXRlSGFuZGxlciA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uICh2YWx1ZXMsIGZpZWxkKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBtYXliZVByb21pc2VkRXJyb3JzID0gcHJvcHMudmFsaWRhdGUodmFsdWVzLCBmaWVsZCk7XG5cbiAgICAgIGlmIChtYXliZVByb21pc2VkRXJyb3JzID09IG51bGwpIHtcbiAgICAgICAgLy8gdXNlIGxvb3NlIG51bGwgY2hlY2sgaGVyZSBvbiBwdXJwb3NlXG4gICAgICAgIHJlc29sdmUoZW1wdHlFcnJvcnMpO1xuICAgICAgfSBlbHNlIGlmIChpc1Byb21pc2UobWF5YmVQcm9taXNlZEVycm9ycykpIHtcbiAgICAgICAgbWF5YmVQcm9taXNlZEVycm9ycy50aGVuKGZ1bmN0aW9uIChlcnJvcnMpIHtcbiAgICAgICAgICByZXNvbHZlKGVycm9ycyB8fCBlbXB0eUVycm9ycyk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChhY3R1YWxFeGNlcHRpb24pIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiV2FybmluZzogQW4gdW5oYW5kbGVkIGVycm9yIHdhcyBjYXVnaHQgZHVyaW5nIHZhbGlkYXRpb24gaW4gPEZvcm1payB2YWxpZGF0ZSAvPlwiLCBhY3R1YWxFeGNlcHRpb24pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlamVjdChhY3R1YWxFeGNlcHRpb24pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUobWF5YmVQcm9taXNlZEVycm9ycyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIFtwcm9wcy52YWxpZGF0ZV0pO1xuICAvKipcclxuICAgKiBSdW4gdmFsaWRhdGlvbiBhZ2FpbnN0IGEgWXVwIHNjaGVtYSBhbmQgb3B0aW9uYWxseSBydW4gYSBmdW5jdGlvbiBpZiBzdWNjZXNzZnVsXHJcbiAgICovXG5cbiAgdmFyIHJ1blZhbGlkYXRpb25TY2hlbWEgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAodmFsdWVzLCBmaWVsZCkge1xuICAgIHZhciB2YWxpZGF0aW9uU2NoZW1hID0gcHJvcHMudmFsaWRhdGlvblNjaGVtYTtcbiAgICB2YXIgc2NoZW1hID0gaXNGdW5jdGlvbih2YWxpZGF0aW9uU2NoZW1hKSA/IHZhbGlkYXRpb25TY2hlbWEoZmllbGQpIDogdmFsaWRhdGlvblNjaGVtYTtcbiAgICB2YXIgcHJvbWlzZSA9IGZpZWxkICYmIHNjaGVtYS52YWxpZGF0ZUF0ID8gc2NoZW1hLnZhbGlkYXRlQXQoZmllbGQsIHZhbHVlcykgOiB2YWxpZGF0ZVl1cFNjaGVtYSh2YWx1ZXMsIHNjaGVtYSk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlc29sdmUoZW1wdHlFcnJvcnMpO1xuICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAvLyBZdXAgd2lsbCB0aHJvdyBhIHZhbGlkYXRpb24gZXJyb3IgaWYgdmFsaWRhdGlvbiBmYWlscy4gV2UgY2F0Y2ggdGhvc2UgYW5kXG4gICAgICAgIC8vIHJlc29sdmUgdGhlbSBpbnRvIEZvcm1payBlcnJvcnMuIFdlIGNhbiBzbmlmZiBpZiBzb21ldGhpbmcgaXMgYSBZdXAgZXJyb3JcbiAgICAgICAgLy8gYnkgY2hlY2tpbmcgZXJyb3IubmFtZS5cbiAgICAgICAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZW5zZS95dXAjdmFsaWRhdGlvbmVycm9yZXJyb3JzLXN0cmluZy0tYXJyYXlzdHJpbmctdmFsdWUtYW55LXBhdGgtc3RyaW5nXG4gICAgICAgIGlmIChlcnIubmFtZSA9PT0gJ1ZhbGlkYXRpb25FcnJvcicpIHtcbiAgICAgICAgICByZXNvbHZlKHl1cFRvRm9ybUVycm9ycyhlcnIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBXZSB0aHJvdyBhbnkgb3RoZXIgZXJyb3JzXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIldhcm5pbmc6IEFuIHVuaGFuZGxlZCBlcnJvciB3YXMgY2F1Z2h0IGR1cmluZyB2YWxpZGF0aW9uIGluIDxGb3JtaWsgdmFsaWRhdGlvblNjaGVtYSAvPlwiLCBlcnIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSwgW3Byb3BzLnZhbGlkYXRpb25TY2hlbWFdKTtcbiAgdmFyIHJ1blNpbmdsZUZpZWxkTGV2ZWxWYWxpZGF0aW9uID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKGZpZWxkLCB2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgcmV0dXJuIHJlc29sdmUoZmllbGRSZWdpc3RyeS5jdXJyZW50W2ZpZWxkXS52YWxpZGF0ZSh2YWx1ZSkpO1xuICAgIH0pO1xuICB9LCBbXSk7XG4gIHZhciBydW5GaWVsZExldmVsVmFsaWRhdGlvbnMgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgdmFyIGZpZWxkS2V5c1dpdGhWYWxpZGF0aW9uID0gT2JqZWN0LmtleXMoZmllbGRSZWdpc3RyeS5jdXJyZW50KS5maWx0ZXIoZnVuY3Rpb24gKGYpIHtcbiAgICAgIHJldHVybiBpc0Z1bmN0aW9uKGZpZWxkUmVnaXN0cnkuY3VycmVudFtmXS52YWxpZGF0ZSk7XG4gICAgfSk7IC8vIENvbnN0cnVjdCBhbiBhcnJheSB3aXRoIGFsbCBvZiB0aGUgZmllbGQgdmFsaWRhdGlvbiBmdW5jdGlvbnNcblxuICAgIHZhciBmaWVsZFZhbGlkYXRpb25zID0gZmllbGRLZXlzV2l0aFZhbGlkYXRpb24ubGVuZ3RoID4gMCA/IGZpZWxkS2V5c1dpdGhWYWxpZGF0aW9uLm1hcChmdW5jdGlvbiAoZikge1xuICAgICAgcmV0dXJuIHJ1blNpbmdsZUZpZWxkTGV2ZWxWYWxpZGF0aW9uKGYsIGdldEluKHZhbHVlcywgZikpO1xuICAgIH0pIDogW1Byb21pc2UucmVzb2x2ZSgnRE9fTk9UX0RFTEVURV9ZT1VfV0lMTF9CRV9GSVJFRCcpXTsgLy8gdXNlIHNwZWNpYWwgY2FzZSA7KVxuXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGZpZWxkVmFsaWRhdGlvbnMpLnRoZW4oZnVuY3Rpb24gKGZpZWxkRXJyb3JzTGlzdCkge1xuICAgICAgcmV0dXJuIGZpZWxkRXJyb3JzTGlzdC5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cnIsIGluZGV4KSB7XG4gICAgICAgIGlmIChjdXJyID09PSAnRE9fTk9UX0RFTEVURV9ZT1VfV0lMTF9CRV9GSVJFRCcpIHtcbiAgICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyKSB7XG4gICAgICAgICAgcHJldiA9IHNldEluKHByZXYsIGZpZWxkS2V5c1dpdGhWYWxpZGF0aW9uW2luZGV4XSwgY3Vycik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgIH0sIHt9KTtcbiAgICB9KTtcbiAgfSwgW3J1blNpbmdsZUZpZWxkTGV2ZWxWYWxpZGF0aW9uXSk7IC8vIFJ1biBhbGwgdmFsaWRhdGlvbnMgYW5kIHJldHVybiB0aGUgcmVzdWx0XG5cbiAgdmFyIHJ1bkFsbFZhbGlkYXRpb25zID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKHZhbHVlcykge1xuICAgIHJldHVybiBQcm9taXNlLmFsbChbcnVuRmllbGRMZXZlbFZhbGlkYXRpb25zKHZhbHVlcyksIHByb3BzLnZhbGlkYXRpb25TY2hlbWEgPyBydW5WYWxpZGF0aW9uU2NoZW1hKHZhbHVlcykgOiB7fSwgcHJvcHMudmFsaWRhdGUgPyBydW5WYWxpZGF0ZUhhbmRsZXIodmFsdWVzKSA6IHt9XSkudGhlbihmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgIHZhciBmaWVsZEVycm9ycyA9IF9yZWYyWzBdLFxuICAgICAgICAgIHNjaGVtYUVycm9ycyA9IF9yZWYyWzFdLFxuICAgICAgICAgIHZhbGlkYXRlRXJyb3JzID0gX3JlZjJbMl07XG4gICAgICB2YXIgY29tYmluZWRFcnJvcnMgPSBkZWVwbWVyZ2UuYWxsKFtmaWVsZEVycm9ycywgc2NoZW1hRXJyb3JzLCB2YWxpZGF0ZUVycm9yc10sIHtcbiAgICAgICAgYXJyYXlNZXJnZTogYXJyYXlNZXJnZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY29tYmluZWRFcnJvcnM7XG4gICAgfSk7XG4gIH0sIFtwcm9wcy52YWxpZGF0ZSwgcHJvcHMudmFsaWRhdGlvblNjaGVtYSwgcnVuRmllbGRMZXZlbFZhbGlkYXRpb25zLCBydW5WYWxpZGF0ZUhhbmRsZXIsIHJ1blZhbGlkYXRpb25TY2hlbWFdKTsgLy8gUnVuIGFsbCB2YWxpZGF0aW9ucyBtZXRob2RzIGFuZCB1cGRhdGUgc3RhdGUgYWNjb3JkaW5nbHlcblxuICB2YXIgdmFsaWRhdGVGb3JtV2l0aEhpZ2hQcmlvcml0eSA9IHVzZUV2ZW50Q2FsbGJhY2soZnVuY3Rpb24gKHZhbHVlcykge1xuICAgIGlmICh2YWx1ZXMgPT09IHZvaWQgMCkge1xuICAgICAgdmFsdWVzID0gc3RhdGUudmFsdWVzO1xuICAgIH1cblxuICAgIGRpc3BhdGNoKHtcbiAgICAgIHR5cGU6ICdTRVRfSVNWQUxJREFUSU5HJyxcbiAgICAgIHBheWxvYWQ6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gcnVuQWxsVmFsaWRhdGlvbnModmFsdWVzKS50aGVuKGZ1bmN0aW9uIChjb21iaW5lZEVycm9ycykge1xuICAgICAgaWYgKCEhaXNNb3VudGVkLmN1cnJlbnQpIHtcbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6ICdTRVRfSVNWQUxJREFUSU5HJyxcbiAgICAgICAgICBwYXlsb2FkOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6ICdTRVRfRVJST1JTJyxcbiAgICAgICAgICBwYXlsb2FkOiBjb21iaW5lZEVycm9yc1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbWJpbmVkRXJyb3JzO1xuICAgIH0pO1xuICB9KTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodmFsaWRhdGVPbk1vdW50ICYmIGlzTW91bnRlZC5jdXJyZW50ID09PSB0cnVlICYmIGlzRXF1YWwoaW5pdGlhbFZhbHVlcy5jdXJyZW50LCBwcm9wcy5pbml0aWFsVmFsdWVzKSkge1xuICAgICAgdmFsaWRhdGVGb3JtV2l0aEhpZ2hQcmlvcml0eShpbml0aWFsVmFsdWVzLmN1cnJlbnQpO1xuICAgIH1cbiAgfSwgW3ZhbGlkYXRlT25Nb3VudCwgdmFsaWRhdGVGb3JtV2l0aEhpZ2hQcmlvcml0eV0pO1xuICB2YXIgcmVzZXRGb3JtID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKG5leHRTdGF0ZSkge1xuICAgIHZhciB2YWx1ZXMgPSBuZXh0U3RhdGUgJiYgbmV4dFN0YXRlLnZhbHVlcyA/IG5leHRTdGF0ZS52YWx1ZXMgOiBpbml0aWFsVmFsdWVzLmN1cnJlbnQ7XG4gICAgdmFyIGVycm9ycyA9IG5leHRTdGF0ZSAmJiBuZXh0U3RhdGUuZXJyb3JzID8gbmV4dFN0YXRlLmVycm9ycyA6IGluaXRpYWxFcnJvcnMuY3VycmVudCA/IGluaXRpYWxFcnJvcnMuY3VycmVudCA6IHByb3BzLmluaXRpYWxFcnJvcnMgfHwge307XG4gICAgdmFyIHRvdWNoZWQgPSBuZXh0U3RhdGUgJiYgbmV4dFN0YXRlLnRvdWNoZWQgPyBuZXh0U3RhdGUudG91Y2hlZCA6IGluaXRpYWxUb3VjaGVkLmN1cnJlbnQgPyBpbml0aWFsVG91Y2hlZC5jdXJyZW50IDogcHJvcHMuaW5pdGlhbFRvdWNoZWQgfHwge307XG4gICAgdmFyIHN0YXR1cyA9IG5leHRTdGF0ZSAmJiBuZXh0U3RhdGUuc3RhdHVzID8gbmV4dFN0YXRlLnN0YXR1cyA6IGluaXRpYWxTdGF0dXMuY3VycmVudCA/IGluaXRpYWxTdGF0dXMuY3VycmVudCA6IHByb3BzLmluaXRpYWxTdGF0dXM7XG4gICAgaW5pdGlhbFZhbHVlcy5jdXJyZW50ID0gdmFsdWVzO1xuICAgIGluaXRpYWxFcnJvcnMuY3VycmVudCA9IGVycm9ycztcbiAgICBpbml0aWFsVG91Y2hlZC5jdXJyZW50ID0gdG91Y2hlZDtcbiAgICBpbml0aWFsU3RhdHVzLmN1cnJlbnQgPSBzdGF0dXM7XG5cbiAgICB2YXIgZGlzcGF0Y2hGbiA9IGZ1bmN0aW9uIGRpc3BhdGNoRm4oKSB7XG4gICAgICBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6ICdSRVNFVF9GT1JNJyxcbiAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgIGlzU3VibWl0dGluZzogISFuZXh0U3RhdGUgJiYgISFuZXh0U3RhdGUuaXNTdWJtaXR0aW5nLFxuICAgICAgICAgIGVycm9yczogZXJyb3JzLFxuICAgICAgICAgIHRvdWNoZWQ6IHRvdWNoZWQsXG4gICAgICAgICAgc3RhdHVzOiBzdGF0dXMsXG4gICAgICAgICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgICAgICAgaXNWYWxpZGF0aW5nOiAhIW5leHRTdGF0ZSAmJiAhIW5leHRTdGF0ZS5pc1ZhbGlkYXRpbmcsXG4gICAgICAgICAgc3VibWl0Q291bnQ6ICEhbmV4dFN0YXRlICYmICEhbmV4dFN0YXRlLnN1Ym1pdENvdW50ICYmIHR5cGVvZiBuZXh0U3RhdGUuc3VibWl0Q291bnQgPT09ICdudW1iZXInID8gbmV4dFN0YXRlLnN1Ym1pdENvdW50IDogMFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgaWYgKHByb3BzLm9uUmVzZXQpIHtcbiAgICAgIHZhciBtYXliZVByb21pc2VkT25SZXNldCA9IHByb3BzLm9uUmVzZXQoc3RhdGUudmFsdWVzLCBpbXBlcmF0aXZlTWV0aG9kcyk7XG5cbiAgICAgIGlmIChpc1Byb21pc2UobWF5YmVQcm9taXNlZE9uUmVzZXQpKSB7XG4gICAgICAgIG1heWJlUHJvbWlzZWRPblJlc2V0LnRoZW4oZGlzcGF0Y2hGbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXNwYXRjaEZuKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpc3BhdGNoRm4oKTtcbiAgICB9XG4gIH0sIFtwcm9wcy5pbml0aWFsRXJyb3JzLCBwcm9wcy5pbml0aWFsU3RhdHVzLCBwcm9wcy5pbml0aWFsVG91Y2hlZCwgcHJvcHMub25SZXNldF0pO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChpc01vdW50ZWQuY3VycmVudCA9PT0gdHJ1ZSAmJiAhaXNFcXVhbChpbml0aWFsVmFsdWVzLmN1cnJlbnQsIHByb3BzLmluaXRpYWxWYWx1ZXMpKSB7XG4gICAgICBpZiAoZW5hYmxlUmVpbml0aWFsaXplKSB7XG4gICAgICAgIGluaXRpYWxWYWx1ZXMuY3VycmVudCA9IHByb3BzLmluaXRpYWxWYWx1ZXM7XG4gICAgICAgIHJlc2V0Rm9ybSgpO1xuXG4gICAgICAgIGlmICh2YWxpZGF0ZU9uTW91bnQpIHtcbiAgICAgICAgICB2YWxpZGF0ZUZvcm1XaXRoSGlnaFByaW9yaXR5KGluaXRpYWxWYWx1ZXMuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIFtlbmFibGVSZWluaXRpYWxpemUsIHByb3BzLmluaXRpYWxWYWx1ZXMsIHJlc2V0Rm9ybSwgdmFsaWRhdGVPbk1vdW50LCB2YWxpZGF0ZUZvcm1XaXRoSGlnaFByaW9yaXR5XSk7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVuYWJsZVJlaW5pdGlhbGl6ZSAmJiBpc01vdW50ZWQuY3VycmVudCA9PT0gdHJ1ZSAmJiAhaXNFcXVhbChpbml0aWFsRXJyb3JzLmN1cnJlbnQsIHByb3BzLmluaXRpYWxFcnJvcnMpKSB7XG4gICAgICBpbml0aWFsRXJyb3JzLmN1cnJlbnQgPSBwcm9wcy5pbml0aWFsRXJyb3JzIHx8IGVtcHR5RXJyb3JzO1xuICAgICAgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiAnU0VUX0VSUk9SUycsXG4gICAgICAgIHBheWxvYWQ6IHByb3BzLmluaXRpYWxFcnJvcnMgfHwgZW1wdHlFcnJvcnNcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW2VuYWJsZVJlaW5pdGlhbGl6ZSwgcHJvcHMuaW5pdGlhbEVycm9yc10pO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbmFibGVSZWluaXRpYWxpemUgJiYgaXNNb3VudGVkLmN1cnJlbnQgPT09IHRydWUgJiYgIWlzRXF1YWwoaW5pdGlhbFRvdWNoZWQuY3VycmVudCwgcHJvcHMuaW5pdGlhbFRvdWNoZWQpKSB7XG4gICAgICBpbml0aWFsVG91Y2hlZC5jdXJyZW50ID0gcHJvcHMuaW5pdGlhbFRvdWNoZWQgfHwgZW1wdHlUb3VjaGVkO1xuICAgICAgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiAnU0VUX1RPVUNIRUQnLFxuICAgICAgICBwYXlsb2FkOiBwcm9wcy5pbml0aWFsVG91Y2hlZCB8fCBlbXB0eVRvdWNoZWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW2VuYWJsZVJlaW5pdGlhbGl6ZSwgcHJvcHMuaW5pdGlhbFRvdWNoZWRdKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZW5hYmxlUmVpbml0aWFsaXplICYmIGlzTW91bnRlZC5jdXJyZW50ID09PSB0cnVlICYmICFpc0VxdWFsKGluaXRpYWxTdGF0dXMuY3VycmVudCwgcHJvcHMuaW5pdGlhbFN0YXR1cykpIHtcbiAgICAgIGluaXRpYWxTdGF0dXMuY3VycmVudCA9IHByb3BzLmluaXRpYWxTdGF0dXM7XG4gICAgICBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6ICdTRVRfU1RBVFVTJyxcbiAgICAgICAgcGF5bG9hZDogcHJvcHMuaW5pdGlhbFN0YXR1c1xuICAgICAgfSk7XG4gICAgfVxuICB9LCBbZW5hYmxlUmVpbml0aWFsaXplLCBwcm9wcy5pbml0aWFsU3RhdHVzLCBwcm9wcy5pbml0aWFsVG91Y2hlZF0pO1xuICB2YXIgdmFsaWRhdGVGaWVsZCA9IHVzZUV2ZW50Q2FsbGJhY2soZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAvLyBUaGlzIHdpbGwgZWZmaWNpZW50bHkgdmFsaWRhdGUgYSBzaW5nbGUgZmllbGQgYnkgYXZvaWRpbmcgc3RhdGVcbiAgICAvLyBjaGFuZ2VzIGlmIHRoZSB2YWxpZGF0aW9uIGZ1bmN0aW9uIGlzIHN5bmNocm9ub3VzLiBJdCdzIGRpZmZlcmVudCBmcm9tXG4gICAgLy8gd2hhdCBpcyBjYWxsZWQgd2hlbiB1c2luZyB2YWxpZGF0ZUZvcm0uXG4gICAgaWYgKGZpZWxkUmVnaXN0cnkuY3VycmVudFtuYW1lXSAmJiBpc0Z1bmN0aW9uKGZpZWxkUmVnaXN0cnkuY3VycmVudFtuYW1lXS52YWxpZGF0ZSkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldEluKHN0YXRlLnZhbHVlcywgbmFtZSk7XG4gICAgICB2YXIgbWF5YmVQcm9taXNlID0gZmllbGRSZWdpc3RyeS5jdXJyZW50W25hbWVdLnZhbGlkYXRlKHZhbHVlKTtcblxuICAgICAgaWYgKGlzUHJvbWlzZShtYXliZVByb21pc2UpKSB7XG4gICAgICAgIC8vIE9ubHkgZmxpcCBpc1ZhbGlkYXRpbmcgaWYgdGhlIGZ1bmN0aW9uIGlzIGFzeW5jLlxuICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogJ1NFVF9JU1ZBTElEQVRJTkcnLFxuICAgICAgICAgIHBheWxvYWQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtYXliZVByb21pc2UudGhlbihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdTRVRfRklFTERfRVJST1InLFxuICAgICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgICBmaWVsZDogbmFtZSxcbiAgICAgICAgICAgICAgdmFsdWU6IGVycm9yXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogJ1NFVF9JU1ZBTElEQVRJTkcnLFxuICAgICAgICAgICAgcGF5bG9hZDogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogJ1NFVF9GSUVMRF9FUlJPUicsXG4gICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgZmllbGQ6IG5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogbWF5YmVQcm9taXNlXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYXliZVByb21pc2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcHMudmFsaWRhdGlvblNjaGVtYSkge1xuICAgICAgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiAnU0VUX0lTVkFMSURBVElORycsXG4gICAgICAgIHBheWxvYWQ6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJ1blZhbGlkYXRpb25TY2hlbWEoc3RhdGUudmFsdWVzLCBuYW1lKS50aGVuKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4O1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6ICdTRVRfRklFTERfRVJST1InLFxuICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgIGZpZWxkOiBuYW1lLFxuICAgICAgICAgICAgdmFsdWU6IGdldEluKGVycm9yLCBuYW1lKVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiAnU0VUX0lTVkFMSURBVElORycsXG4gICAgICAgICAgcGF5bG9hZDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH0pO1xuICB2YXIgcmVnaXN0ZXJGaWVsZCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChuYW1lLCBfcmVmMykge1xuICAgIHZhciB2YWxpZGF0ZSA9IF9yZWYzLnZhbGlkYXRlO1xuICAgIGZpZWxkUmVnaXN0cnkuY3VycmVudFtuYW1lXSA9IHtcbiAgICAgIHZhbGlkYXRlOiB2YWxpZGF0ZVxuICAgIH07XG4gIH0sIFtdKTtcbiAgdmFyIHVucmVnaXN0ZXJGaWVsZCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgZGVsZXRlIGZpZWxkUmVnaXN0cnkuY3VycmVudFtuYW1lXTtcbiAgfSwgW10pO1xuICB2YXIgc2V0VG91Y2hlZCA9IHVzZUV2ZW50Q2FsbGJhY2soZnVuY3Rpb24gKHRvdWNoZWQsIHNob3VsZFZhbGlkYXRlKSB7XG4gICAgZGlzcGF0Y2goe1xuICAgICAgdHlwZTogJ1NFVF9UT1VDSEVEJyxcbiAgICAgIHBheWxvYWQ6IHRvdWNoZWRcbiAgICB9KTtcbiAgICB2YXIgd2lsbFZhbGlkYXRlID0gc2hvdWxkVmFsaWRhdGUgPT09IHVuZGVmaW5lZCA/IHZhbGlkYXRlT25CbHVyIDogc2hvdWxkVmFsaWRhdGU7XG4gICAgcmV0dXJuIHdpbGxWYWxpZGF0ZSA/IHZhbGlkYXRlRm9ybVdpdGhIaWdoUHJpb3JpdHkoc3RhdGUudmFsdWVzKSA6IFByb21pc2UucmVzb2x2ZSgpO1xuICB9KTtcbiAgdmFyIHNldEVycm9ycyA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChlcnJvcnMpIHtcbiAgICBkaXNwYXRjaCh7XG4gICAgICB0eXBlOiAnU0VUX0VSUk9SUycsXG4gICAgICBwYXlsb2FkOiBlcnJvcnNcbiAgICB9KTtcbiAgfSwgW10pO1xuICB2YXIgc2V0VmFsdWVzID0gdXNlRXZlbnRDYWxsYmFjayhmdW5jdGlvbiAodmFsdWVzLCBzaG91bGRWYWxpZGF0ZSkge1xuICAgIHZhciByZXNvbHZlZFZhbHVlcyA9IGlzRnVuY3Rpb24odmFsdWVzKSA/IHZhbHVlcyhzdGF0ZS52YWx1ZXMpIDogdmFsdWVzO1xuICAgIGRpc3BhdGNoKHtcbiAgICAgIHR5cGU6ICdTRVRfVkFMVUVTJyxcbiAgICAgIHBheWxvYWQ6IHJlc29sdmVkVmFsdWVzXG4gICAgfSk7XG4gICAgdmFyIHdpbGxWYWxpZGF0ZSA9IHNob3VsZFZhbGlkYXRlID09PSB1bmRlZmluZWQgPyB2YWxpZGF0ZU9uQ2hhbmdlIDogc2hvdWxkVmFsaWRhdGU7XG4gICAgcmV0dXJuIHdpbGxWYWxpZGF0ZSA/IHZhbGlkYXRlRm9ybVdpdGhIaWdoUHJpb3JpdHkocmVzb2x2ZWRWYWx1ZXMpIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH0pO1xuICB2YXIgc2V0RmllbGRFcnJvciA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChmaWVsZCwgdmFsdWUpIHtcbiAgICBkaXNwYXRjaCh7XG4gICAgICB0eXBlOiAnU0VUX0ZJRUxEX0VSUk9SJyxcbiAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgW10pO1xuICB2YXIgc2V0RmllbGRWYWx1ZSA9IHVzZUV2ZW50Q2FsbGJhY2soZnVuY3Rpb24gKGZpZWxkLCB2YWx1ZSwgc2hvdWxkVmFsaWRhdGUpIHtcbiAgICBkaXNwYXRjaCh7XG4gICAgICB0eXBlOiAnU0VUX0ZJRUxEX1ZBTFVFJyxcbiAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgd2lsbFZhbGlkYXRlID0gc2hvdWxkVmFsaWRhdGUgPT09IHVuZGVmaW5lZCA/IHZhbGlkYXRlT25DaGFuZ2UgOiBzaG91bGRWYWxpZGF0ZTtcbiAgICByZXR1cm4gd2lsbFZhbGlkYXRlID8gdmFsaWRhdGVGb3JtV2l0aEhpZ2hQcmlvcml0eShzZXRJbihzdGF0ZS52YWx1ZXMsIGZpZWxkLCB2YWx1ZSkpIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH0pO1xuICB2YXIgZXhlY3V0ZUNoYW5nZSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChldmVudE9yVGV4dFZhbHVlLCBtYXliZVBhdGgpIHtcbiAgICAvLyBCeSBkZWZhdWx0LCBhc3N1bWUgdGhhdCB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYSBzdHJpbmcuIFRoaXMgYWxsb3dzIHVzIHRvIHVzZVxuICAgIC8vIGhhbmRsZUNoYW5nZSB3aXRoIFJlYWN0IE5hdGl2ZSBhbmQgUmVhY3QgTmF0aXZlIFdlYidzIG9uQ2hhbmdlVGV4dCBwcm9wIHdoaWNoXG4gICAgLy8gcHJvdmlkZXMganVzdCB0aGUgdmFsdWUgb2YgdGhlIGlucHV0LlxuICAgIHZhciBmaWVsZCA9IG1heWJlUGF0aDtcbiAgICB2YXIgdmFsID0gZXZlbnRPclRleHRWYWx1ZTtcbiAgICB2YXIgcGFyc2VkOyAvLyBJZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgbm90IGEgc3RyaW5nIHRob3VnaCwgaXQgaGFzIHRvIGJlIGEgc3ludGhldGljIFJlYWN0IEV2ZW50IChvciBhIGZha2Ugb25lKSxcbiAgICAvLyBzbyB3ZSBoYW5kbGUgbGlrZSB3ZSB3b3VsZCBhIG5vcm1hbCBIVE1MIGNoYW5nZSBldmVudC5cblxuICAgIGlmICghaXNTdHJpbmcoZXZlbnRPclRleHRWYWx1ZSkpIHtcbiAgICAgIC8vIElmIHdlIGNhbiwgcGVyc2lzdCB0aGUgZXZlbnRcbiAgICAgIC8vIEBzZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL2V2ZW50cy5odG1sI2V2ZW50LXBvb2xpbmdcbiAgICAgIGlmIChldmVudE9yVGV4dFZhbHVlLnBlcnNpc3QpIHtcbiAgICAgICAgZXZlbnRPclRleHRWYWx1ZS5wZXJzaXN0KCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0YXJnZXQgPSBldmVudE9yVGV4dFZhbHVlLnRhcmdldCA/IGV2ZW50T3JUZXh0VmFsdWUudGFyZ2V0IDogZXZlbnRPclRleHRWYWx1ZS5jdXJyZW50VGFyZ2V0O1xuICAgICAgdmFyIHR5cGUgPSB0YXJnZXQudHlwZSxcbiAgICAgICAgICBuYW1lID0gdGFyZ2V0Lm5hbWUsXG4gICAgICAgICAgaWQgPSB0YXJnZXQuaWQsXG4gICAgICAgICAgdmFsdWUgPSB0YXJnZXQudmFsdWUsXG4gICAgICAgICAgY2hlY2tlZCA9IHRhcmdldC5jaGVja2VkLFxuICAgICAgICAgIG91dGVySFRNTCA9IHRhcmdldC5vdXRlckhUTUwsXG4gICAgICAgICAgb3B0aW9ucyA9IHRhcmdldC5vcHRpb25zLFxuICAgICAgICAgIG11bHRpcGxlID0gdGFyZ2V0Lm11bHRpcGxlO1xuICAgICAgZmllbGQgPSBtYXliZVBhdGggPyBtYXliZVBhdGggOiBuYW1lID8gbmFtZSA6IGlkO1xuXG4gICAgICBpZiAoIWZpZWxkICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICB3YXJuQWJvdXRNaXNzaW5nSWRlbnRpZmllcih7XG4gICAgICAgICAgaHRtbENvbnRlbnQ6IG91dGVySFRNTCxcbiAgICAgICAgICBkb2N1bWVudGF0aW9uQW5jaG9yTGluazogJ2hhbmRsZWNoYW5nZS1lLXJlYWN0Y2hhbmdlZXZlbnRhbnktLXZvaWQnLFxuICAgICAgICAgIGhhbmRsZXJOYW1lOiAnaGFuZGxlQ2hhbmdlJ1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdmFsID0gL251bWJlcnxyYW5nZS8udGVzdCh0eXBlKSA/IChwYXJzZWQgPSBwYXJzZUZsb2F0KHZhbHVlKSwgaXNOYU4ocGFyc2VkKSA/ICcnIDogcGFyc2VkKSA6IC9jaGVja2JveC8udGVzdCh0eXBlKSAvLyBjaGVja2JveGVzXG4gICAgICA/IGdldFZhbHVlRm9yQ2hlY2tib3goZ2V0SW4oc3RhdGUudmFsdWVzLCBmaWVsZCksIGNoZWNrZWQsIHZhbHVlKSA6IG9wdGlvbnMgJiYgbXVsdGlwbGUgLy8gPHNlbGVjdCBtdWx0aXBsZT5cbiAgICAgID8gZ2V0U2VsZWN0ZWRWYWx1ZXMob3B0aW9ucykgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoZmllbGQpIHtcbiAgICAgIC8vIFNldCBmb3JtIGZpZWxkcyBieSBuYW1lXG4gICAgICBzZXRGaWVsZFZhbHVlKGZpZWxkLCB2YWwpO1xuICAgIH1cbiAgfSwgW3NldEZpZWxkVmFsdWUsIHN0YXRlLnZhbHVlc10pO1xuICB2YXIgaGFuZGxlQ2hhbmdlID0gdXNlRXZlbnRDYWxsYmFjayhmdW5jdGlvbiAoZXZlbnRPclBhdGgpIHtcbiAgICBpZiAoaXNTdHJpbmcoZXZlbnRPclBhdGgpKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBleGVjdXRlQ2hhbmdlKGV2ZW50LCBldmVudE9yUGF0aCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBleGVjdXRlQ2hhbmdlKGV2ZW50T3JQYXRoKTtcbiAgICB9XG4gIH0pO1xuICB2YXIgc2V0RmllbGRUb3VjaGVkID0gdXNlRXZlbnRDYWxsYmFjayhmdW5jdGlvbiAoZmllbGQsIHRvdWNoZWQsIHNob3VsZFZhbGlkYXRlKSB7XG4gICAgaWYgKHRvdWNoZWQgPT09IHZvaWQgMCkge1xuICAgICAgdG91Y2hlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgZGlzcGF0Y2goe1xuICAgICAgdHlwZTogJ1NFVF9GSUVMRF9UT1VDSEVEJyxcbiAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgICB2YWx1ZTogdG91Y2hlZFxuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciB3aWxsVmFsaWRhdGUgPSBzaG91bGRWYWxpZGF0ZSA9PT0gdW5kZWZpbmVkID8gdmFsaWRhdGVPbkJsdXIgOiBzaG91bGRWYWxpZGF0ZTtcbiAgICByZXR1cm4gd2lsbFZhbGlkYXRlID8gdmFsaWRhdGVGb3JtV2l0aEhpZ2hQcmlvcml0eShzdGF0ZS52YWx1ZXMpIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH0pO1xuICB2YXIgZXhlY3V0ZUJsdXIgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoZSwgcGF0aCkge1xuICAgIGlmIChlLnBlcnNpc3QpIHtcbiAgICAgIGUucGVyc2lzdCgpO1xuICAgIH1cblxuICAgIHZhciBfZSR0YXJnZXQgPSBlLnRhcmdldCxcbiAgICAgICAgbmFtZSA9IF9lJHRhcmdldC5uYW1lLFxuICAgICAgICBpZCA9IF9lJHRhcmdldC5pZCxcbiAgICAgICAgb3V0ZXJIVE1MID0gX2UkdGFyZ2V0Lm91dGVySFRNTDtcbiAgICB2YXIgZmllbGQgPSBwYXRoID8gcGF0aCA6IG5hbWUgPyBuYW1lIDogaWQ7XG5cbiAgICBpZiAoIWZpZWxkICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgd2FybkFib3V0TWlzc2luZ0lkZW50aWZpZXIoe1xuICAgICAgICBodG1sQ29udGVudDogb3V0ZXJIVE1MLFxuICAgICAgICBkb2N1bWVudGF0aW9uQW5jaG9yTGluazogJ2hhbmRsZWJsdXItZS1hbnktLXZvaWQnLFxuICAgICAgICBoYW5kbGVyTmFtZTogJ2hhbmRsZUJsdXInXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBzZXRGaWVsZFRvdWNoZWQoZmllbGQsIHRydWUpO1xuICB9LCBbc2V0RmllbGRUb3VjaGVkXSk7XG4gIHZhciBoYW5kbGVCbHVyID0gdXNlRXZlbnRDYWxsYmFjayhmdW5jdGlvbiAoZXZlbnRPclN0cmluZykge1xuICAgIGlmIChpc1N0cmluZyhldmVudE9yU3RyaW5nKSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICByZXR1cm4gZXhlY3V0ZUJsdXIoZXZlbnQsIGV2ZW50T3JTdHJpbmcpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhlY3V0ZUJsdXIoZXZlbnRPclN0cmluZyk7XG4gICAgfVxuICB9KTtcbiAgdmFyIHNldEZvcm1pa1N0YXRlID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKHN0YXRlT3JDYikge1xuICAgIGlmIChpc0Z1bmN0aW9uKHN0YXRlT3JDYikpIHtcbiAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogJ1NFVF9GT1JNSUtfU1RBVEUnLFxuICAgICAgICBwYXlsb2FkOiBzdGF0ZU9yQ2JcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6ICdTRVRfRk9STUlLX1NUQVRFJyxcbiAgICAgICAgcGF5bG9hZDogZnVuY3Rpb24gcGF5bG9hZCgpIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGVPckNiO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtdKTtcbiAgdmFyIHNldFN0YXR1cyA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgICBkaXNwYXRjaCh7XG4gICAgICB0eXBlOiAnU0VUX1NUQVRVUycsXG4gICAgICBwYXlsb2FkOiBzdGF0dXNcbiAgICB9KTtcbiAgfSwgW10pO1xuICB2YXIgc2V0U3VibWl0dGluZyA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChpc1N1Ym1pdHRpbmcpIHtcbiAgICBkaXNwYXRjaCh7XG4gICAgICB0eXBlOiAnU0VUX0lTU1VCTUlUVElORycsXG4gICAgICBwYXlsb2FkOiBpc1N1Ym1pdHRpbmdcbiAgICB9KTtcbiAgfSwgW10pO1xuICB2YXIgc3VibWl0Rm9ybSA9IHVzZUV2ZW50Q2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIGRpc3BhdGNoKHtcbiAgICAgIHR5cGU6ICdTVUJNSVRfQVRURU1QVCdcbiAgICB9KTtcbiAgICByZXR1cm4gdmFsaWRhdGVGb3JtV2l0aEhpZ2hQcmlvcml0eSgpLnRoZW4oZnVuY3Rpb24gKGNvbWJpbmVkRXJyb3JzKSB7XG4gICAgICAvLyBJbiBjYXNlIGFuIGVycm9yIHdhcyB0aHJvd24gYW5kIHBhc3NlZCB0byB0aGUgcmVzb2x2ZWQgUHJvbWlzZSxcbiAgICAgIC8vIGBjb21iaW5lZEVycm9yc2AgY2FuIGJlIGFuIGluc3RhbmNlIG9mIGFuIEVycm9yLiBXZSBuZWVkIHRvIGNoZWNrXG4gICAgICAvLyB0aGF0IGFuZCBhYm9ydCB0aGUgc3VibWl0LlxuICAgICAgLy8gSWYgd2UgZG9uJ3QgZG8gdGhhdCwgY2FsbGluZyBgT2JqZWN0LmtleXMobmV3IEVycm9yKCkpYCB5aWVsZHMgYW5cbiAgICAgIC8vIGVtcHR5IGFycmF5LCB3aGljaCBjYXVzZXMgdGhlIHZhbGlkYXRpb24gdG8gcGFzcyBhbmQgdGhlIGZvcm1cbiAgICAgIC8vIHRvIGJlIHN1Ym1pdHRlZC5cbiAgICAgIHZhciBpc0luc3RhbmNlT2ZFcnJvciA9IGNvbWJpbmVkRXJyb3JzIGluc3RhbmNlb2YgRXJyb3I7XG4gICAgICB2YXIgaXNBY3R1YWxseVZhbGlkID0gIWlzSW5zdGFuY2VPZkVycm9yICYmIE9iamVjdC5rZXlzKGNvbWJpbmVkRXJyb3JzKS5sZW5ndGggPT09IDA7XG5cbiAgICAgIGlmIChpc0FjdHVhbGx5VmFsaWQpIHtcbiAgICAgICAgLy8gUHJvY2VlZCB3aXRoIHN1Ym1pdC4uLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUbyByZXNwZWN0IHN5bmMgc3VibWl0IGZucywgd2UgY2FuJ3Qgc2ltcGx5IHdyYXAgZXhlY3V0ZVN1Ym1pdCBpbiBhIHByb21pc2UgYW5kXG4gICAgICAgIC8vIF9hbHdheXNfIGRpc3BhdGNoIFNVQk1JVF9TVUNDRVNTIGJlY2F1c2UgaXNTdWJtaXR0aW5nIHdvdWxkIHRoZW4gYWx3YXlzIGJlIGZhbHNlLlxuICAgICAgICAvLyBUaGlzIHdvdWxkIGJlIGZpbmUgaW4gc2ltcGxlIGNhc2VzLCBidXQgbWFrZSBpdCBpbXBvc3NpYmxlIHRvIGRpc2FibGUgc3VibWl0XG4gICAgICAgIC8vIGJ1dHRvbnMgd2hlcmUgcGVvcGxlIHVzZSBjYWxsYmFja3Mgb3IgcHJvbWlzZXMgYXMgc2lkZSBlZmZlY3RzICh3aGljaCBpcyBiYXNpY2FsbHlcbiAgICAgICAgLy8gYWxsIG9mIHYxIEZvcm1payBjb2RlKS4gSW5zdGVhZCwgcmVjYWxsIHRoYXQgd2UgYXJlIGluc2lkZSBvZiBhIHByb21pc2UgY2hhaW4gYWxyZWFkeSxcbiAgICAgICAgLy8gIHNvIHdlIGNhbiB0cnkvY2F0Y2ggZXhlY3V0ZVN1Ym1pdCgpLCBpZiBpdCByZXR1cm5zIHVuZGVmaW5lZCwgdGhlbiBqdXN0IGJhaWwuXG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBlcnJvcnMsIHRocm93IGVtLiBPdGhlcndpc2UsIHdyYXAgZXhlY3V0ZVN1Ym1pdCBpbiBhIHByb21pc2UgYW5kIGhhbmRsZVxuICAgICAgICAvLyBjbGVhbnVwIG9mIGlzU3VibWl0dGluZyBvbiBiZWhhbGYgb2YgdGhlIGNvbnN1bWVyLlxuICAgICAgICB2YXIgcHJvbWlzZU9yVW5kZWZpbmVkO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcHJvbWlzZU9yVW5kZWZpbmVkID0gZXhlY3V0ZVN1Ym1pdCgpOyAvLyBCYWlsIGlmIGl0J3Mgc3luYywgY29uc3VtZXIgaXMgcmVzcG9uc2libGUgZm9yIGNsZWFuaW5nIHVwXG4gICAgICAgICAgLy8gdmlhIHNldFN1Ym1pdHRpbmcoZmFsc2UpXG5cbiAgICAgICAgICBpZiAocHJvbWlzZU9yVW5kZWZpbmVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHByb21pc2VPclVuZGVmaW5lZCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgaWYgKCEhaXNNb3VudGVkLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgdHlwZTogJ1NVQk1JVF9TVUNDRVNTJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoX2Vycm9ycykge1xuICAgICAgICAgIGlmICghIWlzTW91bnRlZC5jdXJyZW50KSB7XG4gICAgICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgICAgIHR5cGU6ICdTVUJNSVRfRkFJTFVSRSdcbiAgICAgICAgICAgIH0pOyAvLyBUaGlzIGlzIGEgbGVnaXQgZXJyb3IgcmVqZWN0ZWQgYnkgdGhlIG9uU3VibWl0IGZuXG4gICAgICAgICAgICAvLyBzbyB3ZSBkb24ndCB3YW50IHRvIGJyZWFrIHRoZSBwcm9taXNlIGNoYWluXG5cbiAgICAgICAgICAgIHRocm93IF9lcnJvcnM7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoISFpc01vdW50ZWQuY3VycmVudCkge1xuICAgICAgICAvLyBeXl4gTWFrZSBzdXJlIEZvcm1payBpcyBzdGlsbCBtb3VudGVkIGJlZm9yZSB1cGRhdGluZyBzdGF0ZVxuICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogJ1NVQk1JVF9GQUlMVVJFJ1xuICAgICAgICB9KTsgLy8gdGhyb3cgY29tYmluZWRFcnJvcnM7XG5cbiAgICAgICAgaWYgKGlzSW5zdGFuY2VPZkVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgY29tYmluZWRFcnJvcnM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH0pO1xuICB9KTtcbiAgdmFyIGhhbmRsZVN1Ym1pdCA9IHVzZUV2ZW50Q2FsbGJhY2soZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZSAmJiBlLnByZXZlbnREZWZhdWx0ICYmIGlzRnVuY3Rpb24oZS5wcmV2ZW50RGVmYXVsdCkpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBpZiAoZSAmJiBlLnN0b3BQcm9wYWdhdGlvbiAmJiBpc0Z1bmN0aW9uKGUuc3RvcFByb3BhZ2F0aW9uKSkge1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9IC8vIFdhcm4gaWYgZm9ybSBzdWJtaXNzaW9uIGlzIHRyaWdnZXJlZCBieSBhIDxidXR0b24+IHdpdGhvdXQgYVxuICAgIC8vIHNwZWNpZmllZCBgdHlwZWAgYXR0cmlidXRlIGR1cmluZyBkZXZlbG9wbWVudC4gVGhpcyBtaXRpZ2F0ZXNcbiAgICAvLyBhIGNvbW1vbiBnb3RjaGEgaW4gZm9ybXMgd2l0aCBib3RoIHJlc2V0IGFuZCBzdWJtaXQgYnV0dG9ucyxcbiAgICAvLyB3aGVyZSB0aGUgZGV2IGZvcmdldHMgdG8gYWRkIHR5cGU9XCJidXR0b25cIiB0byB0aGUgcmVzZXQgYnV0dG9uLlxuXG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIFNhZmVseSBnZXQgdGhlIGFjdGl2ZSBlbGVtZW50ICh3b3JrcyB3aXRoIElFKVxuICAgICAgdmFyIGFjdGl2ZUVsZW1lbnQgPSBnZXRBY3RpdmVFbGVtZW50KCk7XG5cbiAgICAgIGlmIChhY3RpdmVFbGVtZW50ICE9PSBudWxsICYmIGFjdGl2ZUVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MQnV0dG9uRWxlbWVudCkge1xuICAgICAgICAhKGFjdGl2ZUVsZW1lbnQuYXR0cmlidXRlcyAmJiBhY3RpdmVFbGVtZW50LmF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCd0eXBlJykpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnWW91IHN1Ym1pdHRlZCBhIEZvcm1payBmb3JtIHVzaW5nIGEgYnV0dG9uIHdpdGggYW4gdW5zcGVjaWZpZWQgYHR5cGVgIGF0dHJpYnV0ZS4gIE1vc3QgYnJvd3NlcnMgZGVmYXVsdCBidXR0b24gZWxlbWVudHMgdG8gYHR5cGU9XCJzdWJtaXRcImAuIElmIHRoaXMgaXMgbm90IGEgc3VibWl0IGJ1dHRvbiwgcGxlYXNlIGFkZCBgdHlwZT1cImJ1dHRvblwiYC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3VibWl0Rm9ybSgpW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgY29uc29sZS53YXJuKFwiV2FybmluZzogQW4gdW5oYW5kbGVkIGVycm9yIHdhcyBjYXVnaHQgZnJvbSBzdWJtaXRGb3JtKClcIiwgcmVhc29uKTtcbiAgICB9KTtcbiAgfSk7XG4gIHZhciBpbXBlcmF0aXZlTWV0aG9kcyA9IHtcbiAgICByZXNldEZvcm06IHJlc2V0Rm9ybSxcbiAgICB2YWxpZGF0ZUZvcm06IHZhbGlkYXRlRm9ybVdpdGhIaWdoUHJpb3JpdHksXG4gICAgdmFsaWRhdGVGaWVsZDogdmFsaWRhdGVGaWVsZCxcbiAgICBzZXRFcnJvcnM6IHNldEVycm9ycyxcbiAgICBzZXRGaWVsZEVycm9yOiBzZXRGaWVsZEVycm9yLFxuICAgIHNldEZpZWxkVG91Y2hlZDogc2V0RmllbGRUb3VjaGVkLFxuICAgIHNldEZpZWxkVmFsdWU6IHNldEZpZWxkVmFsdWUsXG4gICAgc2V0U3RhdHVzOiBzZXRTdGF0dXMsXG4gICAgc2V0U3VibWl0dGluZzogc2V0U3VibWl0dGluZyxcbiAgICBzZXRUb3VjaGVkOiBzZXRUb3VjaGVkLFxuICAgIHNldFZhbHVlczogc2V0VmFsdWVzLFxuICAgIHNldEZvcm1pa1N0YXRlOiBzZXRGb3JtaWtTdGF0ZSxcbiAgICBzdWJtaXRGb3JtOiBzdWJtaXRGb3JtXG4gIH07XG4gIHZhciBleGVjdXRlU3VibWl0ID0gdXNlRXZlbnRDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG9uU3VibWl0KHN0YXRlLnZhbHVlcywgaW1wZXJhdGl2ZU1ldGhvZHMpO1xuICB9KTtcbiAgdmFyIGhhbmRsZVJlc2V0ID0gdXNlRXZlbnRDYWxsYmFjayhmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlICYmIGUucHJldmVudERlZmF1bHQgJiYgaXNGdW5jdGlvbihlLnByZXZlbnREZWZhdWx0KSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIGlmIChlICYmIGUuc3RvcFByb3BhZ2F0aW9uICYmIGlzRnVuY3Rpb24oZS5zdG9wUHJvcGFnYXRpb24pKSB7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cblxuICAgIHJlc2V0Rm9ybSgpO1xuICB9KTtcbiAgdmFyIGdldEZpZWxkTWV0YSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBnZXRJbihzdGF0ZS52YWx1ZXMsIG5hbWUpLFxuICAgICAgZXJyb3I6IGdldEluKHN0YXRlLmVycm9ycywgbmFtZSksXG4gICAgICB0b3VjaGVkOiAhIWdldEluKHN0YXRlLnRvdWNoZWQsIG5hbWUpLFxuICAgICAgaW5pdGlhbFZhbHVlOiBnZXRJbihpbml0aWFsVmFsdWVzLmN1cnJlbnQsIG5hbWUpLFxuICAgICAgaW5pdGlhbFRvdWNoZWQ6ICEhZ2V0SW4oaW5pdGlhbFRvdWNoZWQuY3VycmVudCwgbmFtZSksXG4gICAgICBpbml0aWFsRXJyb3I6IGdldEluKGluaXRpYWxFcnJvcnMuY3VycmVudCwgbmFtZSlcbiAgICB9O1xuICB9LCBbc3RhdGUuZXJyb3JzLCBzdGF0ZS50b3VjaGVkLCBzdGF0ZS52YWx1ZXNdKTtcbiAgdmFyIGdldEZpZWxkSGVscGVycyA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldFZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZSh2YWx1ZSwgc2hvdWxkVmFsaWRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHNldEZpZWxkVmFsdWUobmFtZSwgdmFsdWUsIHNob3VsZFZhbGlkYXRlKTtcbiAgICAgIH0sXG4gICAgICBzZXRUb3VjaGVkOiBmdW5jdGlvbiBzZXRUb3VjaGVkKHZhbHVlLCBzaG91bGRWYWxpZGF0ZSkge1xuICAgICAgICByZXR1cm4gc2V0RmllbGRUb3VjaGVkKG5hbWUsIHZhbHVlLCBzaG91bGRWYWxpZGF0ZSk7XG4gICAgICB9LFxuICAgICAgc2V0RXJyb3I6IGZ1bmN0aW9uIHNldEVycm9yKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBzZXRGaWVsZEVycm9yKG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbc2V0RmllbGRWYWx1ZSwgc2V0RmllbGRUb3VjaGVkLCBzZXRGaWVsZEVycm9yXSk7XG4gIHZhciBnZXRGaWVsZFByb3BzID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKG5hbWVPck9wdGlvbnMpIHtcbiAgICB2YXIgaXNBbk9iamVjdCA9IGlzT2JqZWN0KG5hbWVPck9wdGlvbnMpO1xuICAgIHZhciBuYW1lID0gaXNBbk9iamVjdCA/IG5hbWVPck9wdGlvbnMubmFtZSA6IG5hbWVPck9wdGlvbnM7XG4gICAgdmFyIHZhbHVlU3RhdGUgPSBnZXRJbihzdGF0ZS52YWx1ZXMsIG5hbWUpO1xuICAgIHZhciBmaWVsZCA9IHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogdmFsdWVTdGF0ZSxcbiAgICAgIG9uQ2hhbmdlOiBoYW5kbGVDaGFuZ2UsXG4gICAgICBvbkJsdXI6IGhhbmRsZUJsdXJcbiAgICB9O1xuXG4gICAgaWYgKGlzQW5PYmplY3QpIHtcbiAgICAgIHZhciB0eXBlID0gbmFtZU9yT3B0aW9ucy50eXBlLFxuICAgICAgICAgIHZhbHVlUHJvcCA9IG5hbWVPck9wdGlvbnMudmFsdWUsXG4gICAgICAgICAgaXMgPSBuYW1lT3JPcHRpb25zLmFzLFxuICAgICAgICAgIG11bHRpcGxlID0gbmFtZU9yT3B0aW9ucy5tdWx0aXBsZTtcblxuICAgICAgaWYgKHR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICAgICAgaWYgKHZhbHVlUHJvcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZmllbGQuY2hlY2tlZCA9ICEhdmFsdWVTdGF0ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaWVsZC5jaGVja2VkID0gISEoQXJyYXkuaXNBcnJheSh2YWx1ZVN0YXRlKSAmJiB+dmFsdWVTdGF0ZS5pbmRleE9mKHZhbHVlUHJvcCkpO1xuICAgICAgICAgIGZpZWxkLnZhbHVlID0gdmFsdWVQcm9wO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdyYWRpbycpIHtcbiAgICAgICAgZmllbGQuY2hlY2tlZCA9IHZhbHVlU3RhdGUgPT09IHZhbHVlUHJvcDtcbiAgICAgICAgZmllbGQudmFsdWUgPSB2YWx1ZVByb3A7XG4gICAgICB9IGVsc2UgaWYgKGlzID09PSAnc2VsZWN0JyAmJiBtdWx0aXBsZSkge1xuICAgICAgICBmaWVsZC52YWx1ZSA9IGZpZWxkLnZhbHVlIHx8IFtdO1xuICAgICAgICBmaWVsZC5tdWx0aXBsZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpZWxkO1xuICB9LCBbaGFuZGxlQmx1ciwgaGFuZGxlQ2hhbmdlLCBzdGF0ZS52YWx1ZXNdKTtcbiAgdmFyIGRpcnR5ID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICFpc0VxdWFsKGluaXRpYWxWYWx1ZXMuY3VycmVudCwgc3RhdGUudmFsdWVzKTtcbiAgfSwgW2luaXRpYWxWYWx1ZXMuY3VycmVudCwgc3RhdGUudmFsdWVzXSk7XG4gIHZhciBpc1ZhbGlkID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBpc0luaXRpYWxWYWxpZCAhPT0gJ3VuZGVmaW5lZCcgPyBkaXJ0eSA/IHN0YXRlLmVycm9ycyAmJiBPYmplY3Qua2V5cyhzdGF0ZS5lcnJvcnMpLmxlbmd0aCA9PT0gMCA6IGlzSW5pdGlhbFZhbGlkICE9PSBmYWxzZSAmJiBpc0Z1bmN0aW9uKGlzSW5pdGlhbFZhbGlkKSA/IGlzSW5pdGlhbFZhbGlkKHByb3BzKSA6IGlzSW5pdGlhbFZhbGlkIDogc3RhdGUuZXJyb3JzICYmIE9iamVjdC5rZXlzKHN0YXRlLmVycm9ycykubGVuZ3RoID09PSAwO1xuICB9LCBbaXNJbml0aWFsVmFsaWQsIGRpcnR5LCBzdGF0ZS5lcnJvcnMsIHByb3BzXSk7XG5cbiAgdmFyIGN0eCA9IF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgIGluaXRpYWxWYWx1ZXM6IGluaXRpYWxWYWx1ZXMuY3VycmVudCxcbiAgICBpbml0aWFsRXJyb3JzOiBpbml0aWFsRXJyb3JzLmN1cnJlbnQsXG4gICAgaW5pdGlhbFRvdWNoZWQ6IGluaXRpYWxUb3VjaGVkLmN1cnJlbnQsXG4gICAgaW5pdGlhbFN0YXR1czogaW5pdGlhbFN0YXR1cy5jdXJyZW50LFxuICAgIGhhbmRsZUJsdXI6IGhhbmRsZUJsdXIsXG4gICAgaGFuZGxlQ2hhbmdlOiBoYW5kbGVDaGFuZ2UsXG4gICAgaGFuZGxlUmVzZXQ6IGhhbmRsZVJlc2V0LFxuICAgIGhhbmRsZVN1Ym1pdDogaGFuZGxlU3VibWl0LFxuICAgIHJlc2V0Rm9ybTogcmVzZXRGb3JtLFxuICAgIHNldEVycm9yczogc2V0RXJyb3JzLFxuICAgIHNldEZvcm1pa1N0YXRlOiBzZXRGb3JtaWtTdGF0ZSxcbiAgICBzZXRGaWVsZFRvdWNoZWQ6IHNldEZpZWxkVG91Y2hlZCxcbiAgICBzZXRGaWVsZFZhbHVlOiBzZXRGaWVsZFZhbHVlLFxuICAgIHNldEZpZWxkRXJyb3I6IHNldEZpZWxkRXJyb3IsXG4gICAgc2V0U3RhdHVzOiBzZXRTdGF0dXMsXG4gICAgc2V0U3VibWl0dGluZzogc2V0U3VibWl0dGluZyxcbiAgICBzZXRUb3VjaGVkOiBzZXRUb3VjaGVkLFxuICAgIHNldFZhbHVlczogc2V0VmFsdWVzLFxuICAgIHN1Ym1pdEZvcm06IHN1Ym1pdEZvcm0sXG4gICAgdmFsaWRhdGVGb3JtOiB2YWxpZGF0ZUZvcm1XaXRoSGlnaFByaW9yaXR5LFxuICAgIHZhbGlkYXRlRmllbGQ6IHZhbGlkYXRlRmllbGQsXG4gICAgaXNWYWxpZDogaXNWYWxpZCxcbiAgICBkaXJ0eTogZGlydHksXG4gICAgdW5yZWdpc3RlckZpZWxkOiB1bnJlZ2lzdGVyRmllbGQsXG4gICAgcmVnaXN0ZXJGaWVsZDogcmVnaXN0ZXJGaWVsZCxcbiAgICBnZXRGaWVsZFByb3BzOiBnZXRGaWVsZFByb3BzLFxuICAgIGdldEZpZWxkTWV0YTogZ2V0RmllbGRNZXRhLFxuICAgIGdldEZpZWxkSGVscGVyczogZ2V0RmllbGRIZWxwZXJzLFxuICAgIHZhbGlkYXRlT25CbHVyOiB2YWxpZGF0ZU9uQmx1cixcbiAgICB2YWxpZGF0ZU9uQ2hhbmdlOiB2YWxpZGF0ZU9uQ2hhbmdlLFxuICAgIHZhbGlkYXRlT25Nb3VudDogdmFsaWRhdGVPbk1vdW50XG4gIH0pO1xuXG4gIHJldHVybiBjdHg7XG59XG5mdW5jdGlvbiBGb3JtaWsocHJvcHMpIHtcbiAgdmFyIGZvcm1pa2JhZyA9IHVzZUZvcm1payhwcm9wcyk7XG4gIHZhciBjb21wb25lbnQgPSBwcm9wcy5jb21wb25lbnQsXG4gICAgICBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgcmVuZGVyID0gcHJvcHMucmVuZGVyLFxuICAgICAgaW5uZXJSZWYgPSBwcm9wcy5pbm5lclJlZjsgLy8gVGhpcyBhbGxvd3MgZm9sa3MgdG8gcGFzcyBhIHJlZiB0byA8Rm9ybWlrIC8+XG5cbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZShpbm5lclJlZiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmb3JtaWtiYWc7XG4gIH0pO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgISFwcm9wcy5yZW5kZXIgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiPEZvcm1payByZW5kZXI+IGhhcyBiZWVuIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgdmVyc2lvbnMgb2YgRm9ybWlrLiBQbGVhc2UgdXNlIGEgY2hpbGQgY2FsbGJhY2sgZnVuY3Rpb24gaW5zdGVhZC4gVG8gZ2V0IHJpZCBvZiB0aGlzIHdhcm5pbmcsIHJlcGxhY2UgPEZvcm1payByZW5kZXI9eyhwcm9wcykgPT4gLi4ufSAvPiB3aXRoIDxGb3JtaWs+eyhwcm9wcykgPT4gLi4ufTwvRm9ybWlrPlwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIH0sIFtdKTtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVFbGVtZW50KEZvcm1pa1Byb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGZvcm1pa2JhZ1xuICB9LCBjb21wb25lbnQgPyBjcmVhdGVFbGVtZW50KGNvbXBvbmVudCwgZm9ybWlrYmFnKSA6IHJlbmRlciA/IHJlbmRlcihmb3JtaWtiYWcpIDogY2hpbGRyZW4gLy8gY2hpbGRyZW4gY29tZSBsYXN0LCBhbHdheXMgY2FsbGVkXG4gID8gaXNGdW5jdGlvbihjaGlsZHJlbikgPyBjaGlsZHJlbihmb3JtaWtiYWcpIDogIWlzRW1wdHlDaGlsZHJlbihjaGlsZHJlbikgPyBDaGlsZHJlbi5vbmx5KGNoaWxkcmVuKSA6IG51bGwgOiBudWxsKTtcbn1cblxuZnVuY3Rpb24gd2FybkFib3V0TWlzc2luZ0lkZW50aWZpZXIoX3JlZjQpIHtcbiAgdmFyIGh0bWxDb250ZW50ID0gX3JlZjQuaHRtbENvbnRlbnQsXG4gICAgICBkb2N1bWVudGF0aW9uQW5jaG9yTGluayA9IF9yZWY0LmRvY3VtZW50YXRpb25BbmNob3JMaW5rLFxuICAgICAgaGFuZGxlck5hbWUgPSBfcmVmNC5oYW5kbGVyTmFtZTtcbiAgY29uc29sZS53YXJuKFwiV2FybmluZzogRm9ybWlrIGNhbGxlZCBgXCIgKyBoYW5kbGVyTmFtZSArIFwiYCwgYnV0IHlvdSBmb3Jnb3QgdG8gcGFzcyBhbiBgaWRgIG9yIGBuYW1lYCBhdHRyaWJ1dGUgdG8geW91ciBpbnB1dDpcXG4gICAgXCIgKyBodG1sQ29udGVudCArIFwiXFxuICAgIEZvcm1payBjYW5ub3QgZGV0ZXJtaW5lIHdoaWNoIHZhbHVlIHRvIHVwZGF0ZS4gRm9yIG1vcmUgaW5mbyBzZWUgaHR0cHM6Ly9mb3JtaWsub3JnL2RvY3MvYXBpL2Zvcm1payNcIiArIGRvY3VtZW50YXRpb25BbmNob3JMaW5rICsgXCJcXG4gIFwiKTtcbn1cbi8qKlxyXG4gKiBUcmFuc2Zvcm0gWXVwIFZhbGlkYXRpb25FcnJvciB0byBhIG1vcmUgdXNhYmxlIG9iamVjdFxyXG4gKi9cblxuXG5mdW5jdGlvbiB5dXBUb0Zvcm1FcnJvcnMoeXVwRXJyb3IpIHtcbiAgdmFyIGVycm9ycyA9IHt9O1xuXG4gIGlmICh5dXBFcnJvci5pbm5lcikge1xuICAgIGlmICh5dXBFcnJvci5pbm5lci5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBzZXRJbihlcnJvcnMsIHl1cEVycm9yLnBhdGgsIHl1cEVycm9yLm1lc3NhZ2UpO1xuICAgIH1cblxuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IHl1cEVycm9yLmlubmVyLCBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yKSwgX2kgPSAwLCBfaXRlcmF0b3IgPSBfaXNBcnJheSA/IF9pdGVyYXRvciA6IF9pdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xuICAgICAgdmFyIF9yZWY1O1xuXG4gICAgICBpZiAoX2lzQXJyYXkpIHtcbiAgICAgICAgaWYgKF9pID49IF9pdGVyYXRvci5sZW5ndGgpIGJyZWFrO1xuICAgICAgICBfcmVmNSA9IF9pdGVyYXRvcltfaSsrXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9pID0gX2l0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKF9pLmRvbmUpIGJyZWFrO1xuICAgICAgICBfcmVmNSA9IF9pLnZhbHVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXJyID0gX3JlZjU7XG5cbiAgICAgIGlmICghZ2V0SW4oZXJyb3JzLCBlcnIucGF0aCkpIHtcbiAgICAgICAgZXJyb3JzID0gc2V0SW4oZXJyb3JzLCBlcnIucGF0aCwgZXJyLm1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlcnJvcnM7XG59XG4vKipcclxuICogVmFsaWRhdGUgYSB5dXAgc2NoZW1hLlxyXG4gKi9cblxuZnVuY3Rpb24gdmFsaWRhdGVZdXBTY2hlbWEodmFsdWVzLCBzY2hlbWEsIHN5bmMsIGNvbnRleHQpIHtcbiAgaWYgKHN5bmMgPT09IHZvaWQgMCkge1xuICAgIHN5bmMgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBub3JtYWxpemVkVmFsdWVzID0gcHJlcGFyZURhdGFGb3JWYWxpZGF0aW9uKHZhbHVlcyk7XG4gIHJldHVybiBzY2hlbWFbc3luYyA/ICd2YWxpZGF0ZVN5bmMnIDogJ3ZhbGlkYXRlJ10obm9ybWFsaXplZFZhbHVlcywge1xuICAgIGFib3J0RWFybHk6IGZhbHNlLFxuICAgIGNvbnRleHQ6IGNvbnRleHQgfHwgbm9ybWFsaXplZFZhbHVlc1xuICB9KTtcbn1cbi8qKlxyXG4gKiBSZWN1cnNpdmVseSBwcmVwYXJlIHZhbHVlcy5cclxuICovXG5cbmZ1bmN0aW9uIHByZXBhcmVEYXRhRm9yVmFsaWRhdGlvbih2YWx1ZXMpIHtcbiAgdmFyIGRhdGEgPSBBcnJheS5pc0FycmF5KHZhbHVlcykgPyBbXSA6IHt9O1xuXG4gIGZvciAodmFyIGsgaW4gdmFsdWVzKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZXMsIGspKSB7XG4gICAgICB2YXIga2V5ID0gU3RyaW5nKGspO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXNba2V5XSkgPT09IHRydWUpIHtcbiAgICAgICAgZGF0YVtrZXldID0gdmFsdWVzW2tleV0ubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSA9PT0gdHJ1ZSB8fCBpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHByZXBhcmVEYXRhRm9yVmFsaWRhdGlvbih2YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gJycgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbHVlc1trZXldKSkge1xuICAgICAgICBkYXRhW2tleV0gPSBwcmVwYXJlRGF0YUZvclZhbGlkYXRpb24odmFsdWVzW2tleV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YVtrZXldID0gdmFsdWVzW2tleV0gIT09ICcnID8gdmFsdWVzW2tleV0gOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG4vKipcclxuICogZGVlcG1lcmdlIGFycmF5IG1lcmdpbmcgYWxnb3JpdGhtXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9LeWxlQU1hdGhld3MvZGVlcG1lcmdlI2NvbWJpbmUtYXJyYXlcclxuICovXG5cbmZ1bmN0aW9uIGFycmF5TWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgdmFyIGRlc3RpbmF0aW9uID0gdGFyZ2V0LnNsaWNlKCk7XG4gIHNvdXJjZS5mb3JFYWNoKGZ1bmN0aW9uIG1lcmdlKGUsIGkpIHtcbiAgICBpZiAodHlwZW9mIGRlc3RpbmF0aW9uW2ldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFyIGNsb25lUmVxdWVzdGVkID0gb3B0aW9ucy5jbG9uZSAhPT0gZmFsc2U7XG4gICAgICB2YXIgc2hvdWxkQ2xvbmUgPSBjbG9uZVJlcXVlc3RlZCAmJiBvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0KGUpO1xuICAgICAgZGVzdGluYXRpb25baV0gPSBzaG91bGRDbG9uZSA/IGRlZXBtZXJnZShBcnJheS5pc0FycmF5KGUpID8gW10gOiB7fSwgZSwgb3B0aW9ucykgOiBlO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdChlKSkge1xuICAgICAgZGVzdGluYXRpb25baV0gPSBkZWVwbWVyZ2UodGFyZ2V0W2ldLCBlLCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKHRhcmdldC5pbmRleE9mKGUpID09PSAtMSkge1xuICAgICAgZGVzdGluYXRpb24ucHVzaChlKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZGVzdGluYXRpb247XG59XG4vKiogUmV0dXJuIG11bHRpIHNlbGVjdCB2YWx1ZXMgYmFzZWQgb24gYW4gYXJyYXkgb2Ygb3B0aW9ucyAqL1xuXG5cbmZ1bmN0aW9uIGdldFNlbGVjdGVkVmFsdWVzKG9wdGlvbnMpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20ob3B0aW9ucykuZmlsdGVyKGZ1bmN0aW9uIChlbCkge1xuICAgIHJldHVybiBlbC5zZWxlY3RlZDtcbiAgfSkubWFwKGZ1bmN0aW9uIChlbCkge1xuICAgIHJldHVybiBlbC52YWx1ZTtcbiAgfSk7XG59XG4vKiogUmV0dXJuIHRoZSBuZXh0IHZhbHVlIGZvciBhIGNoZWNrYm94ICovXG5cblxuZnVuY3Rpb24gZ2V0VmFsdWVGb3JDaGVja2JveChjdXJyZW50VmFsdWUsIGNoZWNrZWQsIHZhbHVlUHJvcCkge1xuICAvLyBJZiB0aGUgY3VycmVudCB2YWx1ZSB3YXMgYSBib29sZWFuLCByZXR1cm4gYSBib29sZWFuXG4gIGlmICh0eXBlb2YgY3VycmVudFZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4gQm9vbGVhbihjaGVja2VkKTtcbiAgfSAvLyBJZiB0aGUgY3VycmVudFZhbHVlIHdhcyBub3QgYSBib29sZWFuIHdlIHdhbnQgdG8gcmV0dXJuIGFuIGFycmF5XG5cblxuICB2YXIgY3VycmVudEFycmF5T2ZWYWx1ZXMgPSBbXTtcbiAgdmFyIGlzVmFsdWVJbkFycmF5ID0gZmFsc2U7XG4gIHZhciBpbmRleCA9IC0xO1xuXG4gIGlmICghQXJyYXkuaXNBcnJheShjdXJyZW50VmFsdWUpKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuICAgIGlmICghdmFsdWVQcm9wIHx8IHZhbHVlUHJvcCA9PSAndHJ1ZScgfHwgdmFsdWVQcm9wID09ICdmYWxzZScpIHtcbiAgICAgIHJldHVybiBCb29sZWFuKGNoZWNrZWQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJZiB0aGUgY3VycmVudCB2YWx1ZSBpcyBhbHJlYWR5IGFuIGFycmF5LCB1c2UgaXRcbiAgICBjdXJyZW50QXJyYXlPZlZhbHVlcyA9IGN1cnJlbnRWYWx1ZTtcbiAgICBpbmRleCA9IGN1cnJlbnRWYWx1ZS5pbmRleE9mKHZhbHVlUHJvcCk7XG4gICAgaXNWYWx1ZUluQXJyYXkgPSBpbmRleCA+PSAwO1xuICB9IC8vIElmIHRoZSBjaGVja2JveCB3YXMgY2hlY2tlZCBhbmQgdGhlIHZhbHVlIGlzIG5vdCBhbHJlYWR5IHByZXNlbnQgaW4gdGhlIGFyYXkgd2Ugd2FudCB0byBhZGQgdGhlIG5ldyB2YWx1ZSB0byB0aGUgYXJyYXkgb2YgdmFsdWVzXG5cblxuICBpZiAoY2hlY2tlZCAmJiB2YWx1ZVByb3AgJiYgIWlzVmFsdWVJbkFycmF5KSB7XG4gICAgcmV0dXJuIGN1cnJlbnRBcnJheU9mVmFsdWVzLmNvbmNhdCh2YWx1ZVByb3ApO1xuICB9IC8vIElmIHRoZSBjaGVja2JveCB3YXMgdW5jaGVja2VkIGFuZCB0aGUgdmFsdWUgaXMgbm90IGluIHRoZSBhcnJheSwgc2ltcGx5IHJldHVybiB0aGUgYWxyZWFkeSBleGlzdGluZyBhcnJheSBvZiB2YWx1ZXNcblxuXG4gIGlmICghaXNWYWx1ZUluQXJyYXkpIHtcbiAgICByZXR1cm4gY3VycmVudEFycmF5T2ZWYWx1ZXM7XG4gIH0gLy8gSWYgdGhlIGNoZWNrYm94IHdhcyB1bmNoZWNrZWQgYW5kIHRoZSB2YWx1ZSBpcyBpbiB0aGUgYXJyYXksIHJlbW92ZSB0aGUgdmFsdWUgYW5kIHJldHVybiB0aGUgYXJyYXlcblxuXG4gIHJldHVybiBjdXJyZW50QXJyYXlPZlZhbHVlcy5zbGljZSgwLCBpbmRleCkuY29uY2F0KGN1cnJlbnRBcnJheU9mVmFsdWVzLnNsaWNlKGluZGV4ICsgMSkpO1xufSAvLyBSZWFjdCBjdXJyZW50bHkgdGhyb3dzIGEgd2FybmluZyB3aGVuIHVzaW5nIHVzZUxheW91dEVmZmVjdCBvbiB0aGUgc2VydmVyLlxuLy8gVG8gZ2V0IGFyb3VuZCBpdCwgd2UgY2FuIGNvbmRpdGlvbmFsbHkgdXNlRWZmZWN0IG9uIHRoZSBzZXJ2ZXIgKG5vLW9wKSBhbmRcbi8vIHVzZUxheW91dEVmZmVjdCBpbiB0aGUgYnJvd3Nlci5cbi8vIEBzZWUgaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZ2FlYXJvbi9lN2Q5N2NkZjM4YTI5MDc5MjRlYTEyZTRlYmRmM2M4NVxuXG5cbnZhciB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJyA/IHVzZUxheW91dEVmZmVjdCA6IHVzZUVmZmVjdDtcblxuZnVuY3Rpb24gdXNlRXZlbnRDYWxsYmFjayhmbikge1xuICB2YXIgcmVmID0gdXNlUmVmKGZuKTsgLy8gd2UgY29weSBhIHJlZiB0byB0aGUgY2FsbGJhY2sgc2NvcGVkIHRvIHRoZSBjdXJyZW50IHN0YXRlL3Byb3BzIG9uIGVhY2ggcmVuZGVyXG5cbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcmVmLmN1cnJlbnQgPSBmbjtcbiAgfSk7XG4gIHJldHVybiB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiByZWYuY3VycmVudC5hcHBseSh2b2lkIDAsIGFyZ3MpO1xuICB9LCBbXSk7XG59XG5cbmZ1bmN0aW9uIHVzZUZpZWxkKHByb3BzT3JGaWVsZE5hbWUpIHtcbiAgdmFyIGZvcm1payA9IHVzZUZvcm1pa0NvbnRleHQoKTtcbiAgdmFyIGdldEZpZWxkUHJvcHMgPSBmb3JtaWsuZ2V0RmllbGRQcm9wcyxcbiAgICAgIGdldEZpZWxkTWV0YSA9IGZvcm1pay5nZXRGaWVsZE1ldGEsXG4gICAgICBnZXRGaWVsZEhlbHBlcnMgPSBmb3JtaWsuZ2V0RmllbGRIZWxwZXJzLFxuICAgICAgcmVnaXN0ZXJGaWVsZCA9IGZvcm1pay5yZWdpc3RlckZpZWxkLFxuICAgICAgdW5yZWdpc3RlckZpZWxkID0gZm9ybWlrLnVucmVnaXN0ZXJGaWVsZDtcbiAgdmFyIGlzQW5PYmplY3QgPSBpc09iamVjdChwcm9wc09yRmllbGROYW1lKTsgLy8gTm9ybWFsaXplIHByb3BzT3JGaWVsZE5hbWUgdG8gRmllbGRIb29rQ29uZmlnPFZhbD5cblxuICB2YXIgcHJvcHMgPSBpc0FuT2JqZWN0ID8gcHJvcHNPckZpZWxkTmFtZSA6IHtcbiAgICBuYW1lOiBwcm9wc09yRmllbGROYW1lXG4gIH07XG4gIHZhciBmaWVsZE5hbWUgPSBwcm9wcy5uYW1lLFxuICAgICAgdmFsaWRhdGVGbiA9IHByb3BzLnZhbGlkYXRlO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChmaWVsZE5hbWUpIHtcbiAgICAgIHJlZ2lzdGVyRmllbGQoZmllbGROYW1lLCB7XG4gICAgICAgIHZhbGlkYXRlOiB2YWxpZGF0ZUZuXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGZpZWxkTmFtZSkge1xuICAgICAgICB1bnJlZ2lzdGVyRmllbGQoZmllbGROYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbcmVnaXN0ZXJGaWVsZCwgdW5yZWdpc3RlckZpZWxkLCBmaWVsZE5hbWUsIHZhbGlkYXRlRm5dKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgIWZvcm1payA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ3VzZUZpZWxkKCkgLyA8RmllbGQgLz4gbXVzdCBiZSB1c2VkIHVuZGVybmVhdGggYSA8Rm9ybWlrPiBjb21wb25lbnQgb3Igd2l0aEZvcm1paygpIGhpZ2hlciBvcmRlciBjb21wb25lbnQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIH1cblxuICAhZmllbGROYW1lID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnSW52YWxpZCBmaWVsZCBuYW1lLiBFaXRoZXIgcGFzcyBgdXNlRmllbGRgIGEgc3RyaW5nIG9yIGFuIG9iamVjdCBjb250YWluaW5nIGEgYG5hbWVgIGtleS4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHZhciBmaWVsZEhlbHBlcnMgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2V0RmllbGRIZWxwZXJzKGZpZWxkTmFtZSk7XG4gIH0sIFtnZXRGaWVsZEhlbHBlcnMsIGZpZWxkTmFtZV0pO1xuICByZXR1cm4gW2dldEZpZWxkUHJvcHMocHJvcHMpLCBnZXRGaWVsZE1ldGEoZmllbGROYW1lKSwgZmllbGRIZWxwZXJzXTtcbn1cbmZ1bmN0aW9uIEZpZWxkKF9yZWYpIHtcbiAgdmFyIHZhbGlkYXRlID0gX3JlZi52YWxpZGF0ZSxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICByZW5kZXIgPSBfcmVmLnJlbmRlcixcbiAgICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIGlzID0gX3JlZi5hcyxcbiAgICAgIGNvbXBvbmVudCA9IF9yZWYuY29tcG9uZW50LFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIFtcInZhbGlkYXRlXCIsIFwibmFtZVwiLCBcInJlbmRlclwiLCBcImNoaWxkcmVuXCIsIFwiYXNcIiwgXCJjb21wb25lbnRcIiwgXCJjbGFzc05hbWVcIl0pO1xuXG4gIHZhciBfdXNlRm9ybWlrQ29udGV4dCA9IHVzZUZvcm1pa0NvbnRleHQoKSxcbiAgICAgIGZvcm1payA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF91c2VGb3JtaWtDb250ZXh0LCBbXCJ2YWxpZGF0ZVwiLCBcInZhbGlkYXRpb25TY2hlbWFcIl0pO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgISFyZW5kZXIgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiPEZpZWxkIHJlbmRlcj4gaGFzIGJlZW4gZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGZ1dHVyZSB2ZXJzaW9ucyBvZiBGb3JtaWsuIFBsZWFzZSB1c2UgYSBjaGlsZCBjYWxsYmFjayBmdW5jdGlvbiBpbnN0ZWFkLiBUbyBnZXQgcmlkIG9mIHRoaXMgd2FybmluZywgcmVwbGFjZSA8RmllbGQgbmFtZT1cXFwiXCIgKyBuYW1lICsgXCJcXFwiIHJlbmRlcj17KHtmaWVsZCwgZm9ybX0pID0+IC4uLn0gLz4gd2l0aCA8RmllbGQgbmFtZT1cXFwiXCIgKyBuYW1lICsgXCJcXFwiPnsoe2ZpZWxkLCBmb3JtLCBtZXRhfSkgPT4gLi4ufTwvRmllbGQ+XCIpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgICEhKGlzICYmIGNoaWxkcmVuICYmIGlzRnVuY3Rpb24oY2hpbGRyZW4pKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ1lvdSBzaG91bGQgbm90IHVzZSA8RmllbGQgYXM+IGFuZCA8RmllbGQgY2hpbGRyZW4+IGFzIGEgZnVuY3Rpb24gaW4gdGhlIHNhbWUgPEZpZWxkPiBjb21wb25lbnQ7IDxGaWVsZCBhcz4gd2lsbCBiZSBpZ25vcmVkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgICEhKGNvbXBvbmVudCAmJiBjaGlsZHJlbiAmJiBpc0Z1bmN0aW9uKGNoaWxkcmVuKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdZb3Ugc2hvdWxkIG5vdCB1c2UgPEZpZWxkIGNvbXBvbmVudD4gYW5kIDxGaWVsZCBjaGlsZHJlbj4gYXMgYSBmdW5jdGlvbiBpbiB0aGUgc2FtZSA8RmllbGQ+IGNvbXBvbmVudDsgPEZpZWxkIGNvbXBvbmVudD4gd2lsbCBiZSBpZ25vcmVkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgICEhKHJlbmRlciAmJiBjaGlsZHJlbiAmJiAhaXNFbXB0eUNoaWxkcmVuKGNoaWxkcmVuKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdZb3Ugc2hvdWxkIG5vdCB1c2UgPEZpZWxkIHJlbmRlcj4gYW5kIDxGaWVsZCBjaGlsZHJlbj4gaW4gdGhlIHNhbWUgPEZpZWxkPiBjb21wb25lbnQ7IDxGaWVsZCBjaGlsZHJlbj4gd2lsbCBiZSBpZ25vcmVkJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICB9LCBbXSk7XG4gIH0gLy8gUmVnaXN0ZXIgZmllbGQgYW5kIGZpZWxkLWxldmVsIHZhbGlkYXRpb24gd2l0aCBwYXJlbnQgPEZvcm1paz5cblxuXG4gIHZhciByZWdpc3RlckZpZWxkID0gZm9ybWlrLnJlZ2lzdGVyRmllbGQsXG4gICAgICB1bnJlZ2lzdGVyRmllbGQgPSBmb3JtaWsudW5yZWdpc3RlckZpZWxkO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJlZ2lzdGVyRmllbGQobmFtZSwge1xuICAgICAgdmFsaWRhdGU6IHZhbGlkYXRlXG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHVucmVnaXN0ZXJGaWVsZChuYW1lKTtcbiAgICB9O1xuICB9LCBbcmVnaXN0ZXJGaWVsZCwgdW5yZWdpc3RlckZpZWxkLCBuYW1lLCB2YWxpZGF0ZV0pO1xuICB2YXIgZmllbGQgPSBmb3JtaWsuZ2V0RmllbGRQcm9wcyhfZXh0ZW5kcyh7XG4gICAgbmFtZTogbmFtZVxuICB9LCBwcm9wcykpO1xuICB2YXIgbWV0YSA9IGZvcm1pay5nZXRGaWVsZE1ldGEobmFtZSk7XG4gIHZhciBsZWdhY3lCYWcgPSB7XG4gICAgZmllbGQ6IGZpZWxkLFxuICAgIGZvcm06IGZvcm1pa1xuICB9O1xuXG4gIGlmIChyZW5kZXIpIHtcbiAgICByZXR1cm4gcmVuZGVyKF9leHRlbmRzKHt9LCBsZWdhY3lCYWcsIHtcbiAgICAgIG1ldGE6IG1ldGFcbiAgICB9KSk7XG4gIH1cblxuICBpZiAoaXNGdW5jdGlvbihjaGlsZHJlbikpIHtcbiAgICByZXR1cm4gY2hpbGRyZW4oX2V4dGVuZHMoe30sIGxlZ2FjeUJhZywge1xuICAgICAgbWV0YTogbWV0YVxuICAgIH0pKTtcbiAgfVxuXG4gIGlmIChjb21wb25lbnQpIHtcbiAgICAvLyBUaGlzIGJlaGF2aW9yIGlzIGJhY2t3YXJkcyBjb21wYXQgd2l0aCBlYXJsaWVyIEZvcm1payAwLjkgdG8gMS54XG4gICAgaWYgKHR5cGVvZiBjb21wb25lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgaW5uZXJSZWYgPSBwcm9wcy5pbm5lclJlZixcbiAgICAgICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UocHJvcHMsIFtcImlubmVyUmVmXCJdKTtcblxuICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoY29tcG9uZW50LCBfZXh0ZW5kcyh7XG4gICAgICAgIHJlZjogaW5uZXJSZWZcbiAgICAgIH0sIGZpZWxkLCByZXN0LCB7XG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lXG4gICAgICB9KSwgY2hpbGRyZW4pO1xuICAgIH0gLy8gV2UgZG9uJ3QgcGFzcyBgbWV0YWAgZm9yIGJhY2t3YXJkcyBjb21wYXRcblxuXG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoY29tcG9uZW50LCBfZXh0ZW5kcyh7XG4gICAgICBmaWVsZDogZmllbGQsXG4gICAgICBmb3JtOiBmb3JtaWtcbiAgICB9LCBwcm9wcywge1xuICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVcbiAgICB9KSwgY2hpbGRyZW4pO1xuICB9IC8vIGRlZmF1bHQgdG8gaW5wdXQgaGVyZSBzbyB3ZSBjYW4gY2hlY2sgZm9yIGJvdGggYGFzYCBhbmQgYGNoaWxkcmVuYCBhYm92ZVxuXG5cbiAgdmFyIGFzRWxlbWVudCA9IGlzIHx8ICdpbnB1dCc7XG5cbiAgaWYgKHR5cGVvZiBhc0VsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIF9pbm5lclJlZiA9IHByb3BzLmlubmVyUmVmLFxuICAgICAgICBfcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBbXCJpbm5lclJlZlwiXSk7XG5cbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudChhc0VsZW1lbnQsIF9leHRlbmRzKHtcbiAgICAgIHJlZjogX2lubmVyUmVmXG4gICAgfSwgZmllbGQsIF9yZXN0LCB7XG4gICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVxuICAgIH0pLCBjaGlsZHJlbik7XG4gIH1cblxuICByZXR1cm4gY3JlYXRlRWxlbWVudChhc0VsZW1lbnQsIF9leHRlbmRzKHt9LCBmaWVsZCwgcHJvcHMsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVxuICB9KSwgY2hpbGRyZW4pO1xufVxuXG52YXIgRm9ybSA9IC8qI19fUFVSRV9fKi9mb3J3YXJkUmVmKGZ1bmN0aW9uIChwcm9wcywgcmVmKSB7XG4gIC8vIGlPUyBuZWVkcyBhbiBcImFjdGlvblwiIGF0dHJpYnV0ZSBmb3IgbmljZSBpbnB1dDogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5NDg1MTYyLzQwNjcyNVxuICAvLyBXZSBkZWZhdWx0IHRoZSBhY3Rpb24gdG8gXCIjXCIgaW4gY2FzZSB0aGUgcHJldmVudERlZmF1bHQgZmFpbHMgKGp1c3QgdXBkYXRlcyB0aGUgVVJMIGhhc2gpXG4gIHZhciBhY3Rpb24gPSBwcm9wcy5hY3Rpb24sXG4gICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UocHJvcHMsIFtcImFjdGlvblwiXSk7XG5cbiAgdmFyIF9hY3Rpb24gPSBhY3Rpb24gIT0gbnVsbCA/IGFjdGlvbiA6ICcjJztcblxuICB2YXIgX3VzZUZvcm1pa0NvbnRleHQgPSB1c2VGb3JtaWtDb250ZXh0KCksXG4gICAgICBoYW5kbGVSZXNldCA9IF91c2VGb3JtaWtDb250ZXh0LmhhbmRsZVJlc2V0LFxuICAgICAgaGFuZGxlU3VibWl0ID0gX3VzZUZvcm1pa0NvbnRleHQuaGFuZGxlU3VibWl0O1xuXG4gIHJldHVybiBjcmVhdGVFbGVtZW50KFwiZm9ybVwiLCBfZXh0ZW5kcyh7XG4gICAgb25TdWJtaXQ6IGhhbmRsZVN1Ym1pdCxcbiAgICByZWY6IHJlZixcbiAgICBvblJlc2V0OiBoYW5kbGVSZXNldCxcbiAgICBhY3Rpb246IF9hY3Rpb25cbiAgfSwgcmVzdCkpO1xufSk7XG5Gb3JtLmRpc3BsYXlOYW1lID0gJ0Zvcm0nO1xuXG4vKipcclxuICogQSBwdWJsaWMgaGlnaGVyLW9yZGVyIGNvbXBvbmVudCB0byBhY2Nlc3MgdGhlIGltcGVyYXRpdmUgQVBJXHJcbiAqL1xuXG5mdW5jdGlvbiB3aXRoRm9ybWlrKF9yZWYpIHtcbiAgdmFyIF9yZWYkbWFwUHJvcHNUb1ZhbHVlcyA9IF9yZWYubWFwUHJvcHNUb1ZhbHVlcyxcbiAgICAgIG1hcFByb3BzVG9WYWx1ZXMgPSBfcmVmJG1hcFByb3BzVG9WYWx1ZXMgPT09IHZvaWQgMCA/IGZ1bmN0aW9uICh2YW5pbGxhUHJvcHMpIHtcbiAgICB2YXIgdmFsID0ge307XG5cbiAgICBmb3IgKHZhciBrIGluIHZhbmlsbGFQcm9wcykge1xuICAgICAgaWYgKHZhbmlsbGFQcm9wcy5oYXNPd25Qcm9wZXJ0eShrKSAmJiB0eXBlb2YgdmFuaWxsYVByb3BzW2tdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEB0b2RvIFR5cGVTY3JpcHQgZml4XG4gICAgICAgIHZhbFtrXSA9IHZhbmlsbGFQcm9wc1trXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsO1xuICB9IDogX3JlZiRtYXBQcm9wc1RvVmFsdWVzLFxuICAgICAgY29uZmlnID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZiwgW1wibWFwUHJvcHNUb1ZhbHVlc1wiXSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUZvcm1payhDb21wb25lbnQkMSkge1xuICAgIHZhciBjb21wb25lbnREaXNwbGF5TmFtZSA9IENvbXBvbmVudCQxLmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudCQxLm5hbWUgfHwgQ29tcG9uZW50JDEuY29uc3RydWN0b3IgJiYgQ29tcG9uZW50JDEuY29uc3RydWN0b3IubmFtZSB8fCAnQ29tcG9uZW50JztcbiAgICAvKipcclxuICAgICAqIFdlIG5lZWQgdG8gdXNlIGNsb3N1cmVzIGhlcmUgZm9yIHRvIHByb3ZpZGUgdGhlIHdyYXBwZWQgY29tcG9uZW50J3MgcHJvcHMgdG9cclxuICAgICAqIHRoZSByZXNwZWN0aXZlIHdpdGhGb3JtaWsgY29uZmlnIG1ldGhvZHMuXHJcbiAgICAgKi9cblxuICAgIHZhciBDID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gICAgICBfaW5oZXJpdHNMb29zZShDLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICAgICAgZnVuY3Rpb24gQygpIHtcbiAgICAgICAgdmFyIF90aGlzO1xuXG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcyA9IF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSB8fCB0aGlzO1xuXG4gICAgICAgIF90aGlzLnZhbGlkYXRlID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICAgICAgICAgIHJldHVybiBjb25maWcudmFsaWRhdGUodmFsdWVzLCBfdGhpcy5wcm9wcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgX3RoaXMudmFsaWRhdGlvblNjaGVtYSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihjb25maWcudmFsaWRhdGlvblNjaGVtYSkgPyBjb25maWcudmFsaWRhdGlvblNjaGVtYShfdGhpcy5wcm9wcykgOiBjb25maWcudmFsaWRhdGlvblNjaGVtYTtcbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpcy5oYW5kbGVTdWJtaXQgPSBmdW5jdGlvbiAodmFsdWVzLCBhY3Rpb25zKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbmZpZy5oYW5kbGVTdWJtaXQodmFsdWVzLCBfZXh0ZW5kcyh7fSwgYWN0aW9ucywge1xuICAgICAgICAgICAgcHJvcHM6IF90aGlzLnByb3BzXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIF90aGlzLnJlbmRlckZvcm1Db21wb25lbnQgPSBmdW5jdGlvbiAoZm9ybWlrUHJvcHMpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChDb21wb25lbnQkMSwgX2V4dGVuZHMoe30sIF90aGlzLnByb3BzLCBmb3JtaWtQcm9wcykpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIF9wcm90byA9IEMucHJvdG90eXBlO1xuXG4gICAgICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfdGhpcyRwcm9wcywgW1wiY2hpbGRyZW5cIl0pO1xuXG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KEZvcm1paywgX2V4dGVuZHMoe30sIHByb3BzLCBjb25maWcsIHtcbiAgICAgICAgICB2YWxpZGF0ZTogY29uZmlnLnZhbGlkYXRlICYmIHRoaXMudmFsaWRhdGUsXG4gICAgICAgICAgdmFsaWRhdGlvblNjaGVtYTogY29uZmlnLnZhbGlkYXRpb25TY2hlbWEgJiYgdGhpcy52YWxpZGF0aW9uU2NoZW1hLFxuICAgICAgICAgIGluaXRpYWxWYWx1ZXM6IG1hcFByb3BzVG9WYWx1ZXModGhpcy5wcm9wcyksXG4gICAgICAgICAgaW5pdGlhbFN0YXR1czogY29uZmlnLm1hcFByb3BzVG9TdGF0dXMgJiYgY29uZmlnLm1hcFByb3BzVG9TdGF0dXModGhpcy5wcm9wcyksXG4gICAgICAgICAgaW5pdGlhbEVycm9yczogY29uZmlnLm1hcFByb3BzVG9FcnJvcnMgJiYgY29uZmlnLm1hcFByb3BzVG9FcnJvcnModGhpcy5wcm9wcyksXG4gICAgICAgICAgaW5pdGlhbFRvdWNoZWQ6IGNvbmZpZy5tYXBQcm9wc1RvVG91Y2hlZCAmJiBjb25maWcubWFwUHJvcHNUb1RvdWNoZWQodGhpcy5wcm9wcyksXG4gICAgICAgICAgb25TdWJtaXQ6IHRoaXMuaGFuZGxlU3VibWl0LFxuICAgICAgICAgIGNoaWxkcmVuOiB0aGlzLnJlbmRlckZvcm1Db21wb25lbnRcbiAgICAgICAgfSkpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIEM7XG4gICAgfShDb21wb25lbnQpO1xuXG4gICAgQy5kaXNwbGF5TmFtZSA9IFwiV2l0aEZvcm1payhcIiArIGNvbXBvbmVudERpc3BsYXlOYW1lICsgXCIpXCI7XG4gICAgcmV0dXJuIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKEMsIENvbXBvbmVudCQxIC8vIGNhc3QgdHlwZSB0byBDb21wb25lbnRDbGFzcyAoZXZlbiBpZiBTRkMpXG4gICAgKTtcbiAgfTtcbn1cblxuLyoqXHJcbiAqIENvbm5lY3QgYW55IGNvbXBvbmVudCB0byBGb3JtaWsgY29udGV4dCwgYW5kIGluamVjdCBhcyBhIHByb3AgY2FsbGVkIGBmb3JtaWtgO1xyXG4gKiBAcGFyYW0gQ29tcCBSZWFjdCBDb21wb25lbnRcclxuICovXG5cbmZ1bmN0aW9uIGNvbm5lY3QoQ29tcCkge1xuICB2YXIgQyA9IGZ1bmN0aW9uIEMocHJvcHMpIHtcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudChGb3JtaWtDb25zdW1lciwgbnVsbCwgZnVuY3Rpb24gKGZvcm1paykge1xuICAgICAgISEhZm9ybWlrID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIkZvcm1payBjb250ZXh0IGlzIHVuZGVmaW5lZCwgcGxlYXNlIHZlcmlmeSB5b3UgYXJlIHJlbmRlcmluZyA8Rm9ybT4sIDxGaWVsZD4sIDxGYXN0RmllbGQ+LCA8RmllbGRBcnJheT4sIG9yIHlvdXIgY3VzdG9tIGNvbnRleHQtdXNpbmcgY29tcG9uZW50IGFzIGEgY2hpbGQgb2YgYSA8Rm9ybWlrPiBjb21wb25lbnQuIENvbXBvbmVudCBuYW1lOiBcIiArIENvbXAubmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoQ29tcCwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICAgIGZvcm1pazogZm9ybWlrXG4gICAgICB9KSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGNvbXBvbmVudERpc3BsYXlOYW1lID0gQ29tcC5kaXNwbGF5TmFtZSB8fCBDb21wLm5hbWUgfHwgQ29tcC5jb25zdHJ1Y3RvciAmJiBDb21wLmNvbnN0cnVjdG9yLm5hbWUgfHwgJ0NvbXBvbmVudCc7IC8vIEFzc2lnbiBDb21wIHRvIEMuV3JhcHBlZENvbXBvbmVudCBzbyB3ZSBjYW4gYWNjZXNzIHRoZSBpbm5lciBjb21wb25lbnQgaW4gdGVzdHNcbiAgLy8gRm9yIGV4YW1wbGUsIDxGaWVsZC5XcmFwcGVkQ29tcG9uZW50IC8+IGdldHMgdXMgPEZpZWxkSW5uZXIvPlxuXG4gIEMuV3JhcHBlZENvbXBvbmVudCA9IENvbXA7XG4gIEMuZGlzcGxheU5hbWUgPSBcIkZvcm1pa0Nvbm5lY3QoXCIgKyBjb21wb25lbnREaXNwbGF5TmFtZSArIFwiKVwiO1xuICByZXR1cm4gaG9pc3ROb25SZWFjdFN0YXRpY3MoQywgQ29tcCAvLyBjYXN0IHR5cGUgdG8gQ29tcG9uZW50Q2xhc3MgKGV2ZW4gaWYgU0ZDKVxuICApO1xufVxuXG4vKipcclxuICogU29tZSBhcnJheSBoZWxwZXJzIVxyXG4gKi9cblxudmFyIG1vdmUgPSBmdW5jdGlvbiBtb3ZlKGFycmF5LCBmcm9tLCB0bykge1xuICB2YXIgY29weSA9IGNvcHlBcnJheUxpa2UoYXJyYXkpO1xuICB2YXIgdmFsdWUgPSBjb3B5W2Zyb21dO1xuICBjb3B5LnNwbGljZShmcm9tLCAxKTtcbiAgY29weS5zcGxpY2UodG8sIDAsIHZhbHVlKTtcbiAgcmV0dXJuIGNvcHk7XG59O1xudmFyIHN3YXAgPSBmdW5jdGlvbiBzd2FwKGFycmF5TGlrZSwgaW5kZXhBLCBpbmRleEIpIHtcbiAgdmFyIGNvcHkgPSBjb3B5QXJyYXlMaWtlKGFycmF5TGlrZSk7XG4gIHZhciBhID0gY29weVtpbmRleEFdO1xuICBjb3B5W2luZGV4QV0gPSBjb3B5W2luZGV4Ql07XG4gIGNvcHlbaW5kZXhCXSA9IGE7XG4gIHJldHVybiBjb3B5O1xufTtcbnZhciBpbnNlcnQgPSBmdW5jdGlvbiBpbnNlcnQoYXJyYXlMaWtlLCBpbmRleCwgdmFsdWUpIHtcbiAgdmFyIGNvcHkgPSBjb3B5QXJyYXlMaWtlKGFycmF5TGlrZSk7XG4gIGNvcHkuc3BsaWNlKGluZGV4LCAwLCB2YWx1ZSk7XG4gIHJldHVybiBjb3B5O1xufTtcbnZhciByZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShhcnJheUxpa2UsIGluZGV4LCB2YWx1ZSkge1xuICB2YXIgY29weSA9IGNvcHlBcnJheUxpa2UoYXJyYXlMaWtlKTtcbiAgY29weVtpbmRleF0gPSB2YWx1ZTtcbiAgcmV0dXJuIGNvcHk7XG59O1xuXG52YXIgY29weUFycmF5TGlrZSA9IGZ1bmN0aW9uIGNvcHlBcnJheUxpa2UoYXJyYXlMaWtlKSB7XG4gIGlmICghYXJyYXlMaWtlKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJyYXlMaWtlKSkge1xuICAgIHJldHVybiBbXS5jb25jYXQoYXJyYXlMaWtlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbWF4SW5kZXggPSBPYmplY3Qua2V5cyhhcnJheUxpa2UpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gcGFyc2VJbnQoa2V5KTtcbiAgICB9KS5yZWR1Y2UoZnVuY3Rpb24gKG1heCwgZWwpIHtcbiAgICAgIHJldHVybiBlbCA+IG1heCA/IGVsIDogbWF4O1xuICAgIH0sIDApO1xuICAgIHJldHVybiBBcnJheS5mcm9tKF9leHRlbmRzKHt9LCBhcnJheUxpa2UsIHtcbiAgICAgIGxlbmd0aDogbWF4SW5kZXggKyAxXG4gICAgfSkpO1xuICB9XG59O1xuXG52YXIgY3JlYXRlQWx0ZXJhdGlvbkhhbmRsZXIgPSBmdW5jdGlvbiBjcmVhdGVBbHRlcmF0aW9uSGFuZGxlcihhbHRlcmF0aW9uLCBkZWZhdWx0RnVuY3Rpb24pIHtcbiAgdmFyIGZuID0gdHlwZW9mIGFsdGVyYXRpb24gPT09ICdmdW5jdGlvbicgPyBhbHRlcmF0aW9uIDogZGVmYXVsdEZ1bmN0aW9uO1xuICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSB8fCBpc09iamVjdChkYXRhKSkge1xuICAgICAgdmFyIGNsb25lID0gY29weUFycmF5TGlrZShkYXRhKTtcbiAgICAgIHJldHVybiBmbihjbG9uZSk7XG4gICAgfSAvLyBUaGlzIGNhbiBiZSBhc3N1bWVkIHRvIGJlIGEgcHJpbWl0aXZlLCB3aGljaFxuICAgIC8vIGlzIGEgY2FzZSBmb3IgdG9wIGxldmVsIHZhbGlkYXRpb24gZXJyb3JzXG5cblxuICAgIHJldHVybiBkYXRhO1xuICB9O1xufTtcblxudmFyIEZpZWxkQXJyYXlJbm5lciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShGaWVsZEFycmF5SW5uZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIEZpZWxkQXJyYXlJbm5lcihwcm9wcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzOyAvLyBXZSBuZWVkIFR5cGVTY3JpcHQgZ2VuZXJpY3Mgb24gdGhlc2UsIHNvIHdlJ2xsIGJpbmQgdGhlbSBpbiB0aGUgY29uc3RydWN0b3JcbiAgICAvLyBAdG9kbyBGaXggVFMgMy4yLjFcblxuICAgIF90aGlzLnVwZGF0ZUFycmF5RmllbGQgPSBmdW5jdGlvbiAoZm4sIGFsdGVyVG91Y2hlZCwgYWx0ZXJFcnJvcnMpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IF90aGlzLnByb3BzLFxuICAgICAgICAgIG5hbWUgPSBfdGhpcyRwcm9wcy5uYW1lLFxuICAgICAgICAgIHNldEZvcm1pa1N0YXRlID0gX3RoaXMkcHJvcHMuZm9ybWlrLnNldEZvcm1pa1N0YXRlO1xuICAgICAgc2V0Rm9ybWlrU3RhdGUoZnVuY3Rpb24gKHByZXZTdGF0ZSkge1xuICAgICAgICB2YXIgdXBkYXRlRXJyb3JzID0gY3JlYXRlQWx0ZXJhdGlvbkhhbmRsZXIoYWx0ZXJFcnJvcnMsIGZuKTtcbiAgICAgICAgdmFyIHVwZGF0ZVRvdWNoZWQgPSBjcmVhdGVBbHRlcmF0aW9uSGFuZGxlcihhbHRlclRvdWNoZWQsIGZuKTsgLy8gdmFsdWVzIGZuIHNob3VsZCBiZSBleGVjdXRlZCBiZWZvcmUgdXBkYXRlRXJyb3JzIGFuZCB1cGRhdGVUb3VjaGVkLFxuICAgICAgICAvLyBvdGhlcndpc2UgaXQgY2F1c2VzIGFuIGVycm9yIHdpdGggdW5zaGlmdC5cblxuICAgICAgICB2YXIgdmFsdWVzID0gc2V0SW4ocHJldlN0YXRlLnZhbHVlcywgbmFtZSwgZm4oZ2V0SW4ocHJldlN0YXRlLnZhbHVlcywgbmFtZSkpKTtcbiAgICAgICAgdmFyIGZpZWxkRXJyb3IgPSBhbHRlckVycm9ycyA/IHVwZGF0ZUVycm9ycyhnZXRJbihwcmV2U3RhdGUuZXJyb3JzLCBuYW1lKSkgOiB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBmaWVsZFRvdWNoZWQgPSBhbHRlclRvdWNoZWQgPyB1cGRhdGVUb3VjaGVkKGdldEluKHByZXZTdGF0ZS50b3VjaGVkLCBuYW1lKSkgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKGlzRW1wdHlBcnJheShmaWVsZEVycm9yKSkge1xuICAgICAgICAgIGZpZWxkRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNFbXB0eUFycmF5KGZpZWxkVG91Y2hlZCkpIHtcbiAgICAgICAgICBmaWVsZFRvdWNoZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHByZXZTdGF0ZSwge1xuICAgICAgICAgIHZhbHVlczogdmFsdWVzLFxuICAgICAgICAgIGVycm9yczogYWx0ZXJFcnJvcnMgPyBzZXRJbihwcmV2U3RhdGUuZXJyb3JzLCBuYW1lLCBmaWVsZEVycm9yKSA6IHByZXZTdGF0ZS5lcnJvcnMsXG4gICAgICAgICAgdG91Y2hlZDogYWx0ZXJUb3VjaGVkID8gc2V0SW4ocHJldlN0YXRlLnRvdWNoZWQsIG5hbWUsIGZpZWxkVG91Y2hlZCkgOiBwcmV2U3RhdGUudG91Y2hlZFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfdGhpcy5wdXNoID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gX3RoaXMudXBkYXRlQXJyYXlGaWVsZChmdW5jdGlvbiAoYXJyYXlMaWtlKSB7XG4gICAgICAgIHJldHVybiBbXS5jb25jYXQoY29weUFycmF5TGlrZShhcnJheUxpa2UpLCBbY2xvbmVEZWVwKHZhbHVlKV0pO1xuICAgICAgfSwgZmFsc2UsIGZhbHNlKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuaGFuZGxlUHVzaCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnB1c2godmFsdWUpO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgX3RoaXMuc3dhcCA9IGZ1bmN0aW9uIChpbmRleEEsIGluZGV4Qikge1xuICAgICAgcmV0dXJuIF90aGlzLnVwZGF0ZUFycmF5RmllbGQoZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgICAgIHJldHVybiBzd2FwKGFycmF5LCBpbmRleEEsIGluZGV4Qik7XG4gICAgICB9LCB0cnVlLCB0cnVlKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuaGFuZGxlU3dhcCA9IGZ1bmN0aW9uIChpbmRleEEsIGluZGV4Qikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnN3YXAoaW5kZXhBLCBpbmRleEIpO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgX3RoaXMubW92ZSA9IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICAgICAgcmV0dXJuIF90aGlzLnVwZGF0ZUFycmF5RmllbGQoZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgICAgIHJldHVybiBtb3ZlKGFycmF5LCBmcm9tLCB0byk7XG4gICAgICB9LCB0cnVlLCB0cnVlKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuaGFuZGxlTW92ZSA9IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLm1vdmUoZnJvbSwgdG8pO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgX3RoaXMuaW5zZXJ0ID0gZnVuY3Rpb24gKGluZGV4LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIF90aGlzLnVwZGF0ZUFycmF5RmllbGQoZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgICAgIHJldHVybiBpbnNlcnQoYXJyYXksIGluZGV4LCB2YWx1ZSk7XG4gICAgICB9LCBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGluc2VydChhcnJheSwgaW5kZXgsIG51bGwpO1xuICAgICAgfSwgZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgICAgIHJldHVybiBpbnNlcnQoYXJyYXksIGluZGV4LCBudWxsKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfdGhpcy5oYW5kbGVJbnNlcnQgPSBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuaW5zZXJ0KGluZGV4LCB2YWx1ZSk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBfdGhpcy5yZXBsYWNlID0gZnVuY3Rpb24gKGluZGV4LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIF90aGlzLnVwZGF0ZUFycmF5RmllbGQoZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgICAgIHJldHVybiByZXBsYWNlKGFycmF5LCBpbmRleCwgdmFsdWUpO1xuICAgICAgfSwgZmFsc2UsIGZhbHNlKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuaGFuZGxlUmVwbGFjZSA9IGZ1bmN0aW9uIChpbmRleCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5yZXBsYWNlKGluZGV4LCB2YWx1ZSk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBfdGhpcy51bnNoaWZ0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gLTE7XG5cbiAgICAgIF90aGlzLnVwZGF0ZUFycmF5RmllbGQoZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgICAgIHZhciBhcnIgPSBhcnJheSA/IFt2YWx1ZV0uY29uY2F0KGFycmF5KSA6IFt2YWx1ZV07XG4gICAgICAgIGxlbmd0aCA9IGFyci5sZW5ndGg7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgICB9LCBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5ID8gW251bGxdLmNvbmNhdChhcnJheSkgOiBbbnVsbF07XG4gICAgICB9LCBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5ID8gW251bGxdLmNvbmNhdChhcnJheSkgOiBbbnVsbF07XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9O1xuXG4gICAgX3RoaXMuaGFuZGxlVW5zaGlmdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnVuc2hpZnQodmFsdWUpO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgX3RoaXMuaGFuZGxlUmVtb3ZlID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMucmVtb3ZlKGluZGV4KTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIF90aGlzLmhhbmRsZVBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5wb3AoKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIF90aGlzLnJlbW92ZSA9IF90aGlzLnJlbW92ZS5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5wb3AgPSBfdGhpcy5wb3AuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEZpZWxkQXJyYXlJbm5lci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICBpZiAodGhpcy5wcm9wcy52YWxpZGF0ZU9uQ2hhbmdlICYmIHRoaXMucHJvcHMuZm9ybWlrLnZhbGlkYXRlT25DaGFuZ2UgJiYgIWlzRXF1YWwoZ2V0SW4ocHJldlByb3BzLmZvcm1pay52YWx1ZXMsIHByZXZQcm9wcy5uYW1lKSwgZ2V0SW4odGhpcy5wcm9wcy5mb3JtaWsudmFsdWVzLCB0aGlzLnByb3BzLm5hbWUpKSkge1xuICAgICAgdGhpcy5wcm9wcy5mb3JtaWsudmFsaWRhdGVGb3JtKHRoaXMucHJvcHMuZm9ybWlrLnZhbHVlcyk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoaW5kZXgpIHtcbiAgICAvLyBXZSBuZWVkIHRvIG1ha2Ugc3VyZSB3ZSBhbHNvIHJlbW92ZSByZWxldmFudCBwaWVjZXMgb2YgYHRvdWNoZWRgIGFuZCBgZXJyb3JzYFxuICAgIHZhciByZXN1bHQ7XG4gICAgdGhpcy51cGRhdGVBcnJheUZpZWxkKCAvLyBzbyB0aGlzIGdldHMgY2FsbCAzIHRpbWVzXG4gICAgZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgICB2YXIgY29weSA9IGFycmF5ID8gY29weUFycmF5TGlrZShhcnJheSkgOiBbXTtcblxuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgcmVzdWx0ID0gY29weVtpbmRleF07XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKGNvcHkuc3BsaWNlKSkge1xuICAgICAgICBjb3B5LnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9IC8vIGlmIHRoZSBhcnJheSBvbmx5IGluY2x1ZGVzIHVuZGVmaW5lZCB2YWx1ZXMgd2UgaGF2ZSB0byByZXR1cm4gYW4gZW1wdHkgYXJyYXlcblxuXG4gICAgICByZXR1cm4gaXNGdW5jdGlvbihjb3B5LmV2ZXJ5KSA/IGNvcHkuZXZlcnkoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIHYgPT09IHVuZGVmaW5lZDtcbiAgICAgIH0pID8gW10gOiBjb3B5IDogY29weTtcbiAgICB9LCB0cnVlLCB0cnVlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIF9wcm90by5wb3AgPSBmdW5jdGlvbiBwb3AoKSB7XG4gICAgLy8gUmVtb3ZlIHJlbGV2YW50IHBpZWNlcyBvZiBgdG91Y2hlZGAgYW5kIGBlcnJvcnNgIHRvbyFcbiAgICB2YXIgcmVzdWx0O1xuICAgIHRoaXMudXBkYXRlQXJyYXlGaWVsZCggLy8gc28gdGhpcyBnZXRzIGNhbGwgMyB0aW1lc1xuICAgIGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgdmFyIHRtcCA9IGFycmF5LnNsaWNlKCk7XG5cbiAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIHJlc3VsdCA9IHRtcCAmJiB0bXAucG9wICYmIHRtcC5wb3AoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRtcDtcbiAgICB9LCB0cnVlLCB0cnVlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIGFycmF5SGVscGVycyA9IHtcbiAgICAgIHB1c2g6IHRoaXMucHVzaCxcbiAgICAgIHBvcDogdGhpcy5wb3AsXG4gICAgICBzd2FwOiB0aGlzLnN3YXAsXG4gICAgICBtb3ZlOiB0aGlzLm1vdmUsXG4gICAgICBpbnNlcnQ6IHRoaXMuaW5zZXJ0LFxuICAgICAgcmVwbGFjZTogdGhpcy5yZXBsYWNlLFxuICAgICAgdW5zaGlmdDogdGhpcy51bnNoaWZ0LFxuICAgICAgcmVtb3ZlOiB0aGlzLnJlbW92ZSxcbiAgICAgIGhhbmRsZVB1c2g6IHRoaXMuaGFuZGxlUHVzaCxcbiAgICAgIGhhbmRsZVBvcDogdGhpcy5oYW5kbGVQb3AsXG4gICAgICBoYW5kbGVTd2FwOiB0aGlzLmhhbmRsZVN3YXAsXG4gICAgICBoYW5kbGVNb3ZlOiB0aGlzLmhhbmRsZU1vdmUsXG4gICAgICBoYW5kbGVJbnNlcnQ6IHRoaXMuaGFuZGxlSW5zZXJ0LFxuICAgICAgaGFuZGxlUmVwbGFjZTogdGhpcy5oYW5kbGVSZXBsYWNlLFxuICAgICAgaGFuZGxlVW5zaGlmdDogdGhpcy5oYW5kbGVVbnNoaWZ0LFxuICAgICAgaGFuZGxlUmVtb3ZlOiB0aGlzLmhhbmRsZVJlbW92ZVxuICAgIH07XG5cbiAgICB2YXIgX3RoaXMkcHJvcHMyID0gdGhpcy5wcm9wcyxcbiAgICAgICAgY29tcG9uZW50ID0gX3RoaXMkcHJvcHMyLmNvbXBvbmVudCxcbiAgICAgICAgcmVuZGVyID0gX3RoaXMkcHJvcHMyLnJlbmRlcixcbiAgICAgICAgY2hpbGRyZW4gPSBfdGhpcyRwcm9wczIuY2hpbGRyZW4sXG4gICAgICAgIG5hbWUgPSBfdGhpcyRwcm9wczIubmFtZSxcbiAgICAgICAgX3RoaXMkcHJvcHMyJGZvcm1payA9IF90aGlzJHByb3BzMi5mb3JtaWssXG4gICAgICAgIHJlc3RPZkZvcm1payA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF90aGlzJHByb3BzMiRmb3JtaWssIFtcInZhbGlkYXRlXCIsIFwidmFsaWRhdGlvblNjaGVtYVwiXSk7XG5cbiAgICB2YXIgcHJvcHMgPSBfZXh0ZW5kcyh7fSwgYXJyYXlIZWxwZXJzLCB7XG4gICAgICBmb3JtOiByZXN0T2ZGb3JtaWssXG4gICAgICBuYW1lOiBuYW1lXG4gICAgfSk7XG5cbiAgICByZXR1cm4gY29tcG9uZW50ID8gY3JlYXRlRWxlbWVudChjb21wb25lbnQsIHByb3BzKSA6IHJlbmRlciA/IHJlbmRlcihwcm9wcykgOiBjaGlsZHJlbiAvLyBjaGlsZHJlbiBjb21lIGxhc3QsIGFsd2F5cyBjYWxsZWRcbiAgICA/IHR5cGVvZiBjaGlsZHJlbiA9PT0gJ2Z1bmN0aW9uJyA/IGNoaWxkcmVuKHByb3BzKSA6ICFpc0VtcHR5Q2hpbGRyZW4oY2hpbGRyZW4pID8gQ2hpbGRyZW4ub25seShjaGlsZHJlbikgOiBudWxsIDogbnVsbDtcbiAgfTtcblxuICByZXR1cm4gRmllbGRBcnJheUlubmVyO1xufShDb21wb25lbnQpO1xuXG5GaWVsZEFycmF5SW5uZXIuZGVmYXVsdFByb3BzID0ge1xuICB2YWxpZGF0ZU9uQ2hhbmdlOiB0cnVlXG59O1xudmFyIEZpZWxkQXJyYXkgPSAvKiNfX1BVUkVfXyovY29ubmVjdChGaWVsZEFycmF5SW5uZXIpO1xuXG52YXIgRXJyb3JNZXNzYWdlSW1wbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShFcnJvck1lc3NhZ2VJbXBsLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBFcnJvck1lc3NhZ2VJbXBsKCkge1xuICAgIHJldHVybiBfUmVhY3QkQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBFcnJvck1lc3NhZ2VJbXBsLnByb3RvdHlwZTtcblxuICBfcHJvdG8uc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZnVuY3Rpb24gc2hvdWxkQ29tcG9uZW50VXBkYXRlKHByb3BzKSB7XG4gICAgaWYgKGdldEluKHRoaXMucHJvcHMuZm9ybWlrLmVycm9ycywgdGhpcy5wcm9wcy5uYW1lKSAhPT0gZ2V0SW4ocHJvcHMuZm9ybWlrLmVycm9ycywgdGhpcy5wcm9wcy5uYW1lKSB8fCBnZXRJbih0aGlzLnByb3BzLmZvcm1pay50b3VjaGVkLCB0aGlzLnByb3BzLm5hbWUpICE9PSBnZXRJbihwcm9wcy5mb3JtaWsudG91Y2hlZCwgdGhpcy5wcm9wcy5uYW1lKSB8fCBPYmplY3Qua2V5cyh0aGlzLnByb3BzKS5sZW5ndGggIT09IE9iamVjdC5rZXlzKHByb3BzKS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgY29tcG9uZW50ID0gX3RoaXMkcHJvcHMuY29tcG9uZW50LFxuICAgICAgICBmb3JtaWsgPSBfdGhpcyRwcm9wcy5mb3JtaWssXG4gICAgICAgIHJlbmRlciA9IF90aGlzJHByb3BzLnJlbmRlcixcbiAgICAgICAgY2hpbGRyZW4gPSBfdGhpcyRwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgbmFtZSA9IF90aGlzJHByb3BzLm5hbWUsXG4gICAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfdGhpcyRwcm9wcywgW1wiY29tcG9uZW50XCIsIFwiZm9ybWlrXCIsIFwicmVuZGVyXCIsIFwiY2hpbGRyZW5cIiwgXCJuYW1lXCJdKTtcblxuICAgIHZhciB0b3VjaCA9IGdldEluKGZvcm1pay50b3VjaGVkLCBuYW1lKTtcbiAgICB2YXIgZXJyb3IgPSBnZXRJbihmb3JtaWsuZXJyb3JzLCBuYW1lKTtcbiAgICByZXR1cm4gISF0b3VjaCAmJiAhIWVycm9yID8gcmVuZGVyID8gaXNGdW5jdGlvbihyZW5kZXIpID8gcmVuZGVyKGVycm9yKSA6IG51bGwgOiBjaGlsZHJlbiA/IGlzRnVuY3Rpb24oY2hpbGRyZW4pID8gY2hpbGRyZW4oZXJyb3IpIDogbnVsbCA6IGNvbXBvbmVudCA/IGNyZWF0ZUVsZW1lbnQoY29tcG9uZW50LCByZXN0LCBlcnJvcikgOiBlcnJvciA6IG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIEVycm9yTWVzc2FnZUltcGw7XG59KENvbXBvbmVudCk7XG5cbnZhciBFcnJvck1lc3NhZ2UgPSAvKiNfX1BVUkVfXyovY29ubmVjdChFcnJvck1lc3NhZ2VJbXBsKTtcblxuLyoqXHJcbiAqIEN1c3RvbSBGaWVsZCBjb21wb25lbnQgZm9yIHF1aWNrbHkgaG9va2luZyBpbnRvIEZvcm1pa1xyXG4gKiBjb250ZXh0IGFuZCB3aXJpbmcgdXAgZm9ybXMuXHJcbiAqL1xuXG52YXIgRmFzdEZpZWxkSW5uZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoRmFzdEZpZWxkSW5uZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIEZhc3RGaWVsZElubmVyKHByb3BzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfUmVhY3QkQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XG4gICAgdmFyIHJlbmRlciA9IHByb3BzLnJlbmRlcixcbiAgICAgICAgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgY29tcG9uZW50ID0gcHJvcHMuY29tcG9uZW50LFxuICAgICAgICBpcyA9IHByb3BzLmFzLFxuICAgICAgICBuYW1lID0gcHJvcHMubmFtZTtcbiAgICAhIXJlbmRlciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCI8RmFzdEZpZWxkIHJlbmRlcj4gaGFzIGJlZW4gZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBhIGNoaWxkIGNhbGxiYWNrIGZ1bmN0aW9uIGluc3RlYWQ6IDxGYXN0RmllbGQgbmFtZT17XCIgKyBuYW1lICsgXCJ9Pntwcm9wcyA9PiAuLi59PC9GYXN0RmllbGQ+IGluc3RlYWQuXCIpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAhIShjb21wb25lbnQgJiYgcmVuZGVyKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ1lvdSBzaG91bGQgbm90IHVzZSA8RmFzdEZpZWxkIGNvbXBvbmVudD4gYW5kIDxGYXN0RmllbGQgcmVuZGVyPiBpbiB0aGUgc2FtZSA8RmFzdEZpZWxkPiBjb21wb25lbnQ7IDxGYXN0RmllbGQgY29tcG9uZW50PiB3aWxsIGJlIGlnbm9yZWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgISEoaXMgJiYgY2hpbGRyZW4gJiYgaXNGdW5jdGlvbihjaGlsZHJlbikpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnWW91IHNob3VsZCBub3QgdXNlIDxGYXN0RmllbGQgYXM+IGFuZCA8RmFzdEZpZWxkIGNoaWxkcmVuPiBhcyBhIGZ1bmN0aW9uIGluIHRoZSBzYW1lIDxGYXN0RmllbGQ+IGNvbXBvbmVudDsgPEZhc3RGaWVsZCBhcz4gd2lsbCBiZSBpZ25vcmVkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAhIShjb21wb25lbnQgJiYgY2hpbGRyZW4gJiYgaXNGdW5jdGlvbihjaGlsZHJlbikpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnWW91IHNob3VsZCBub3QgdXNlIDxGYXN0RmllbGQgY29tcG9uZW50PiBhbmQgPEZhc3RGaWVsZCBjaGlsZHJlbj4gYXMgYSBmdW5jdGlvbiBpbiB0aGUgc2FtZSA8RmFzdEZpZWxkPiBjb21wb25lbnQ7IDxGYXN0RmllbGQgY29tcG9uZW50PiB3aWxsIGJlIGlnbm9yZWQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICEhKHJlbmRlciAmJiBjaGlsZHJlbiAmJiAhaXNFbXB0eUNoaWxkcmVuKGNoaWxkcmVuKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdZb3Ugc2hvdWxkIG5vdCB1c2UgPEZhc3RGaWVsZCByZW5kZXI+IGFuZCA8RmFzdEZpZWxkIGNoaWxkcmVuPiBpbiB0aGUgc2FtZSA8RmFzdEZpZWxkPiBjb21wb25lbnQ7IDxGYXN0RmllbGQgY2hpbGRyZW4+IHdpbGwgYmUgaWdub3JlZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gRmFzdEZpZWxkSW5uZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbiBzaG91bGRDb21wb25lbnRVcGRhdGUocHJvcHMpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5zaG91bGRVcGRhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3BzLnNob3VsZFVwZGF0ZShwcm9wcywgdGhpcy5wcm9wcyk7XG4gICAgfSBlbHNlIGlmIChwcm9wcy5uYW1lICE9PSB0aGlzLnByb3BzLm5hbWUgfHwgZ2V0SW4ocHJvcHMuZm9ybWlrLnZhbHVlcywgdGhpcy5wcm9wcy5uYW1lKSAhPT0gZ2V0SW4odGhpcy5wcm9wcy5mb3JtaWsudmFsdWVzLCB0aGlzLnByb3BzLm5hbWUpIHx8IGdldEluKHByb3BzLmZvcm1pay5lcnJvcnMsIHRoaXMucHJvcHMubmFtZSkgIT09IGdldEluKHRoaXMucHJvcHMuZm9ybWlrLmVycm9ycywgdGhpcy5wcm9wcy5uYW1lKSB8fCBnZXRJbihwcm9wcy5mb3JtaWsudG91Y2hlZCwgdGhpcy5wcm9wcy5uYW1lKSAhPT0gZ2V0SW4odGhpcy5wcm9wcy5mb3JtaWsudG91Y2hlZCwgdGhpcy5wcm9wcy5uYW1lKSB8fCBPYmplY3Qua2V5cyh0aGlzLnByb3BzKS5sZW5ndGggIT09IE9iamVjdC5rZXlzKHByb3BzKS5sZW5ndGggfHwgcHJvcHMuZm9ybWlrLmlzU3VibWl0dGluZyAhPT0gdGhpcy5wcm9wcy5mb3JtaWsuaXNTdWJtaXR0aW5nKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAvLyBSZWdpc3RlciB0aGUgRmllbGQgd2l0aCB0aGUgcGFyZW50IEZvcm1pay4gUGFyZW50IHdpbGwgY3ljbGUgdGhyb3VnaFxuICAgIC8vIHJlZ2lzdGVyZWQgRmllbGQncyB2YWxpZGF0ZSBmbnMgcmlnaHQgcHJpb3IgdG8gc3VibWl0XG4gICAgdGhpcy5wcm9wcy5mb3JtaWsucmVnaXN0ZXJGaWVsZCh0aGlzLnByb3BzLm5hbWUsIHtcbiAgICAgIHZhbGlkYXRlOiB0aGlzLnByb3BzLnZhbGlkYXRlXG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5uYW1lICE9PSBwcmV2UHJvcHMubmFtZSkge1xuICAgICAgdGhpcy5wcm9wcy5mb3JtaWsudW5yZWdpc3RlckZpZWxkKHByZXZQcm9wcy5uYW1lKTtcbiAgICAgIHRoaXMucHJvcHMuZm9ybWlrLnJlZ2lzdGVyRmllbGQodGhpcy5wcm9wcy5uYW1lLCB7XG4gICAgICAgIHZhbGlkYXRlOiB0aGlzLnByb3BzLnZhbGlkYXRlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wcm9wcy52YWxpZGF0ZSAhPT0gcHJldlByb3BzLnZhbGlkYXRlKSB7XG4gICAgICB0aGlzLnByb3BzLmZvcm1pay5yZWdpc3RlckZpZWxkKHRoaXMucHJvcHMubmFtZSwge1xuICAgICAgICB2YWxpZGF0ZTogdGhpcy5wcm9wcy52YWxpZGF0ZVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMucHJvcHMuZm9ybWlrLnVucmVnaXN0ZXJGaWVsZCh0aGlzLnByb3BzLm5hbWUpO1xuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgbmFtZSA9IF90aGlzJHByb3BzLm5hbWUsXG4gICAgICAgIHJlbmRlciA9IF90aGlzJHByb3BzLnJlbmRlcixcbiAgICAgICAgaXMgPSBfdGhpcyRwcm9wcy5hcyxcbiAgICAgICAgY2hpbGRyZW4gPSBfdGhpcyRwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgY29tcG9uZW50ID0gX3RoaXMkcHJvcHMuY29tcG9uZW50LFxuICAgICAgICBmb3JtaWsgPSBfdGhpcyRwcm9wcy5mb3JtaWssXG4gICAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3RoaXMkcHJvcHMsIFtcInZhbGlkYXRlXCIsIFwibmFtZVwiLCBcInJlbmRlclwiLCBcImFzXCIsIFwiY2hpbGRyZW5cIiwgXCJjb21wb25lbnRcIiwgXCJzaG91bGRVcGRhdGVcIiwgXCJmb3JtaWtcIl0pO1xuXG4gICAgdmFyIHJlc3RPZkZvcm1payA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKGZvcm1paywgW1widmFsaWRhdGVcIiwgXCJ2YWxpZGF0aW9uU2NoZW1hXCJdKTtcblxuICAgIHZhciBmaWVsZCA9IGZvcm1pay5nZXRGaWVsZFByb3BzKF9leHRlbmRzKHtcbiAgICAgIG5hbWU6IG5hbWVcbiAgICB9LCBwcm9wcykpO1xuICAgIHZhciBtZXRhID0ge1xuICAgICAgdmFsdWU6IGdldEluKGZvcm1pay52YWx1ZXMsIG5hbWUpLFxuICAgICAgZXJyb3I6IGdldEluKGZvcm1pay5lcnJvcnMsIG5hbWUpLFxuICAgICAgdG91Y2hlZDogISFnZXRJbihmb3JtaWsudG91Y2hlZCwgbmFtZSksXG4gICAgICBpbml0aWFsVmFsdWU6IGdldEluKGZvcm1pay5pbml0aWFsVmFsdWVzLCBuYW1lKSxcbiAgICAgIGluaXRpYWxUb3VjaGVkOiAhIWdldEluKGZvcm1pay5pbml0aWFsVG91Y2hlZCwgbmFtZSksXG4gICAgICBpbml0aWFsRXJyb3I6IGdldEluKGZvcm1pay5pbml0aWFsRXJyb3JzLCBuYW1lKVxuICAgIH07XG4gICAgdmFyIGJhZyA9IHtcbiAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgIG1ldGE6IG1ldGEsXG4gICAgICBmb3JtOiByZXN0T2ZGb3JtaWtcbiAgICB9O1xuXG4gICAgaWYgKHJlbmRlcikge1xuICAgICAgcmV0dXJuIHJlbmRlcihiYWcpO1xuICAgIH1cblxuICAgIGlmIChpc0Z1bmN0aW9uKGNoaWxkcmVuKSkge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuKGJhZyk7XG4gICAgfVxuXG4gICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgLy8gVGhpcyBiZWhhdmlvciBpcyBiYWNrd2FyZHMgY29tcGF0IHdpdGggZWFybGllciBGb3JtaWsgMC45IHRvIDEueFxuICAgICAgaWYgKHR5cGVvZiBjb21wb25lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciBpbm5lclJlZiA9IHByb3BzLmlubmVyUmVmLFxuICAgICAgICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBbXCJpbm5lclJlZlwiXSk7XG5cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoY29tcG9uZW50LCBfZXh0ZW5kcyh7XG4gICAgICAgICAgcmVmOiBpbm5lclJlZlxuICAgICAgICB9LCBmaWVsZCwgcmVzdCksIGNoaWxkcmVuKTtcbiAgICAgIH0gLy8gV2UgZG9uJ3QgcGFzcyBgbWV0YWAgZm9yIGJhY2t3YXJkcyBjb21wYXRcblxuXG4gICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChjb21wb25lbnQsIF9leHRlbmRzKHtcbiAgICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgICBmb3JtOiBmb3JtaWtcbiAgICAgIH0sIHByb3BzKSwgY2hpbGRyZW4pO1xuICAgIH0gLy8gZGVmYXVsdCB0byBpbnB1dCBoZXJlIHNvIHdlIGNhbiBjaGVjayBmb3IgYm90aCBgYXNgIGFuZCBgY2hpbGRyZW5gIGFib3ZlXG5cblxuICAgIHZhciBhc0VsZW1lbnQgPSBpcyB8fCAnaW5wdXQnO1xuXG4gICAgaWYgKHR5cGVvZiBhc0VsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgX2lubmVyUmVmID0gcHJvcHMuaW5uZXJSZWYsXG4gICAgICAgICAgX3Jlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgW1wiaW5uZXJSZWZcIl0pO1xuXG4gICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChhc0VsZW1lbnQsIF9leHRlbmRzKHtcbiAgICAgICAgcmVmOiBfaW5uZXJSZWZcbiAgICAgIH0sIGZpZWxkLCBfcmVzdCksIGNoaWxkcmVuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudChhc0VsZW1lbnQsIF9leHRlbmRzKHt9LCBmaWVsZCwgcHJvcHMpLCBjaGlsZHJlbik7XG4gIH07XG5cbiAgcmV0dXJuIEZhc3RGaWVsZElubmVyO1xufShDb21wb25lbnQpO1xuXG52YXIgRmFzdEZpZWxkID0gLyojX19QVVJFX18qL2Nvbm5lY3QoRmFzdEZpZWxkSW5uZXIpO1xuXG5leHBvcnQgeyBFcnJvck1lc3NhZ2UsIEZhc3RGaWVsZCwgRmllbGQsIEZpZWxkQXJyYXksIEZvcm0sIEZvcm1paywgRm9ybWlrQ29uc3VtZXIsIEZvcm1pa0NvbnRleHQsIEZvcm1pa1Byb3ZpZGVyLCBjb25uZWN0LCBnZXRBY3RpdmVFbGVtZW50LCBnZXRJbiwgaW5zZXJ0LCBpc0VtcHR5QXJyYXksIGlzRW1wdHlDaGlsZHJlbiwgaXNGdW5jdGlvbiwgaXNJbnB1dEV2ZW50LCBpc0ludGVnZXIsIGlzTmFOJDEgYXMgaXNOYU4sIGlzT2JqZWN0LCBpc1Byb21pc2UsIGlzU3RyaW5nLCBtb3ZlLCBwcmVwYXJlRGF0YUZvclZhbGlkYXRpb24sIHJlcGxhY2UsIHNldEluLCBzZXROZXN0ZWRPYmplY3RWYWx1ZXMsIHN3YXAsIHVzZUZpZWxkLCB1c2VGb3JtaWssIHVzZUZvcm1pa0NvbnRleHQsIHZhbGlkYXRlWXVwU2NoZW1hLCB3aXRoRm9ybWlrLCB5dXBUb0Zvcm1FcnJvcnMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvcm1pay5lc20uanMubWFwXG4iXSwibmFtZXMiOlsiZGVlcG1lcmdlIiwiaXNQbGFpbk9iamVjdCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwiQ2hpbGRyZW4iLCJ1c2VSZWYiLCJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsInVzZUNhbGxiYWNrIiwidXNlTWVtbyIsInVzZUltcGVyYXRpdmVIYW5kbGUiLCJjcmVhdGVFbGVtZW50IiwidXNlTGF5b3V0RWZmZWN0IiwiZm9yd2FyZFJlZiIsIkNvbXBvbmVudCIsImlzRXF1YWwiLCJpbnZhcmlhbnQiLCJjbG9uZSIsInRvUGF0aCIsImhvaXN0Tm9uUmVhY3RTdGF0aWNzIiwiY2xvbmVEZWVwIiwiX2V4dGVuZHMiLCJPYmplY3QiLCJhc3NpZ24iLCJ0YXJnZXQiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwia2V5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiYXBwbHkiLCJfaW5oZXJpdHNMb29zZSIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsImNyZWF0ZSIsImNvbnN0cnVjdG9yIiwiX19wcm90b19fIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UiLCJleGNsdWRlZCIsInNvdXJjZUtleXMiLCJrZXlzIiwiaW5kZXhPZiIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJzZWxmIiwiUmVmZXJlbmNlRXJyb3IiLCJGb3JtaWtDb250ZXh0IiwidW5kZWZpbmVkIiwiZGlzcGxheU5hbWUiLCJGb3JtaWtQcm92aWRlciIsIlByb3ZpZGVyIiwiRm9ybWlrQ29uc3VtZXIiLCJDb25zdW1lciIsInVzZUZvcm1pa0NvbnRleHQiLCJmb3JtaWsiLCJwcm9jZXNzIiwiaXNFbXB0eUFycmF5IiwidmFsdWUiLCJBcnJheSIsImlzQXJyYXkiLCJpc0Z1bmN0aW9uIiwib2JqIiwiaXNPYmplY3QiLCJpc0ludGVnZXIiLCJTdHJpbmciLCJNYXRoIiwiZmxvb3IiLCJOdW1iZXIiLCJpc1N0cmluZyIsInRvU3RyaW5nIiwiaXNOYU4kMSIsImlzTmFOIiwiaXNFbXB0eUNoaWxkcmVuIiwiY2hpbGRyZW4iLCJjb3VudCIsImlzUHJvbWlzZSIsInRoZW4iLCJpc0lucHV0RXZlbnQiLCJnZXRBY3RpdmVFbGVtZW50IiwiZG9jIiwiZG9jdW1lbnQiLCJhY3RpdmVFbGVtZW50IiwiYm9keSIsImUiLCJnZXRJbiIsImRlZiIsInAiLCJwYXRoIiwic2V0SW4iLCJyZXMiLCJyZXNWYWwiLCJwYXRoQXJyYXkiLCJjdXJyZW50UGF0aCIsImN1cnJlbnRPYmoiLCJzbGljZSIsIm5leHRQYXRoIiwic2V0TmVzdGVkT2JqZWN0VmFsdWVzIiwib2JqZWN0IiwidmlzaXRlZCIsInJlc3BvbnNlIiwiV2Vha01hcCIsIl9pIiwiX09iamVjdCRrZXlzIiwiayIsInZhbCIsImdldCIsInNldCIsImZvcm1pa1JlZHVjZXIiLCJzdGF0ZSIsIm1zZyIsInR5cGUiLCJ2YWx1ZXMiLCJwYXlsb2FkIiwidG91Y2hlZCIsImVycm9ycyIsInN0YXR1cyIsImlzU3VibWl0dGluZyIsImlzVmFsaWRhdGluZyIsImZpZWxkIiwic3VibWl0Q291bnQiLCJlbXB0eUVycm9ycyIsImVtcHR5VG91Y2hlZCIsInVzZUZvcm1payIsIl9yZWYiLCJfcmVmJHZhbGlkYXRlT25DaGFuZ2UiLCJ2YWxpZGF0ZU9uQ2hhbmdlIiwiX3JlZiR2YWxpZGF0ZU9uQmx1ciIsInZhbGlkYXRlT25CbHVyIiwiX3JlZiR2YWxpZGF0ZU9uTW91bnQiLCJ2YWxpZGF0ZU9uTW91bnQiLCJpc0luaXRpYWxWYWxpZCIsIl9yZWYkZW5hYmxlUmVpbml0aWFsaSIsImVuYWJsZVJlaW5pdGlhbGl6ZSIsIm9uU3VibWl0IiwicmVzdCIsInByb3BzIiwiaW5pdGlhbFZhbHVlcyIsImluaXRpYWxFcnJvcnMiLCJpbml0aWFsVG91Y2hlZCIsImluaXRpYWxTdGF0dXMiLCJpc01vdW50ZWQiLCJmaWVsZFJlZ2lzdHJ5IiwiY3VycmVudCIsIl9SZWFjdCR1c2VTdGF0ZSIsInNldEl0ZXJhdGlvbiIsInN0YXRlUmVmIiwiZGlzcGF0Y2giLCJhY3Rpb24iLCJwcmV2IiwieCIsInJ1blZhbGlkYXRlSGFuZGxlciIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwibWF5YmVQcm9taXNlZEVycm9ycyIsInZhbGlkYXRlIiwiYWN0dWFsRXhjZXB0aW9uIiwiY29uc29sZSIsIndhcm4iLCJydW5WYWxpZGF0aW9uU2NoZW1hIiwidmFsaWRhdGlvblNjaGVtYSIsInNjaGVtYSIsInByb21pc2UiLCJ2YWxpZGF0ZUF0IiwidmFsaWRhdGVZdXBTY2hlbWEiLCJlcnIiLCJuYW1lIiwieXVwVG9Gb3JtRXJyb3JzIiwicnVuU2luZ2xlRmllbGRMZXZlbFZhbGlkYXRpb24iLCJydW5GaWVsZExldmVsVmFsaWRhdGlvbnMiLCJmaWVsZEtleXNXaXRoVmFsaWRhdGlvbiIsImZpbHRlciIsImYiLCJmaWVsZFZhbGlkYXRpb25zIiwibWFwIiwiYWxsIiwiZmllbGRFcnJvcnNMaXN0IiwicmVkdWNlIiwiY3VyciIsImluZGV4IiwicnVuQWxsVmFsaWRhdGlvbnMiLCJfcmVmMiIsImZpZWxkRXJyb3JzIiwic2NoZW1hRXJyb3JzIiwidmFsaWRhdGVFcnJvcnMiLCJjb21iaW5lZEVycm9ycyIsImFycmF5TWVyZ2UiLCJ2YWxpZGF0ZUZvcm1XaXRoSGlnaFByaW9yaXR5IiwidXNlRXZlbnRDYWxsYmFjayIsInJlc2V0Rm9ybSIsIm5leHRTdGF0ZSIsImRpc3BhdGNoRm4iLCJvblJlc2V0IiwibWF5YmVQcm9taXNlZE9uUmVzZXQiLCJpbXBlcmF0aXZlTWV0aG9kcyIsInZhbGlkYXRlRmllbGQiLCJtYXliZVByb21pc2UiLCJlcnJvciIsInJlZ2lzdGVyRmllbGQiLCJfcmVmMyIsInVucmVnaXN0ZXJGaWVsZCIsInNldFRvdWNoZWQiLCJzaG91bGRWYWxpZGF0ZSIsIndpbGxWYWxpZGF0ZSIsInNldEVycm9ycyIsInNldFZhbHVlcyIsInJlc29sdmVkVmFsdWVzIiwic2V0RmllbGRFcnJvciIsInNldEZpZWxkVmFsdWUiLCJleGVjdXRlQ2hhbmdlIiwiZXZlbnRPclRleHRWYWx1ZSIsIm1heWJlUGF0aCIsInBhcnNlZCIsInBlcnNpc3QiLCJjdXJyZW50VGFyZ2V0IiwiaWQiLCJjaGVja2VkIiwib3V0ZXJIVE1MIiwib3B0aW9ucyIsIm11bHRpcGxlIiwid2FybkFib3V0TWlzc2luZ0lkZW50aWZpZXIiLCJodG1sQ29udGVudCIsImRvY3VtZW50YXRpb25BbmNob3JMaW5rIiwiaGFuZGxlck5hbWUiLCJ0ZXN0IiwicGFyc2VGbG9hdCIsImdldFZhbHVlRm9yQ2hlY2tib3giLCJnZXRTZWxlY3RlZFZhbHVlcyIsImhhbmRsZUNoYW5nZSIsImV2ZW50T3JQYXRoIiwiZXZlbnQiLCJzZXRGaWVsZFRvdWNoZWQiLCJleGVjdXRlQmx1ciIsIl9lJHRhcmdldCIsImhhbmRsZUJsdXIiLCJldmVudE9yU3RyaW5nIiwic2V0Rm9ybWlrU3RhdGUiLCJzdGF0ZU9yQ2IiLCJzZXRTdGF0dXMiLCJzZXRTdWJtaXR0aW5nIiwic3VibWl0Rm9ybSIsImlzSW5zdGFuY2VPZkVycm9yIiwiRXJyb3IiLCJpc0FjdHVhbGx5VmFsaWQiLCJwcm9taXNlT3JVbmRlZmluZWQiLCJleGVjdXRlU3VibWl0IiwicmVzdWx0IiwiX2Vycm9ycyIsImhhbmRsZVN1Ym1pdCIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwiSFRNTEJ1dHRvbkVsZW1lbnQiLCJhdHRyaWJ1dGVzIiwiZ2V0TmFtZWRJdGVtIiwicmVhc29uIiwidmFsaWRhdGVGb3JtIiwiaGFuZGxlUmVzZXQiLCJnZXRGaWVsZE1ldGEiLCJpbml0aWFsVmFsdWUiLCJpbml0aWFsRXJyb3IiLCJnZXRGaWVsZEhlbHBlcnMiLCJzZXRWYWx1ZSIsInNldEVycm9yIiwiZ2V0RmllbGRQcm9wcyIsIm5hbWVPck9wdGlvbnMiLCJpc0FuT2JqZWN0IiwidmFsdWVTdGF0ZSIsIm9uQ2hhbmdlIiwib25CbHVyIiwidmFsdWVQcm9wIiwiaXMiLCJhcyIsImRpcnR5IiwiaXNWYWxpZCIsImN0eCIsIkZvcm1payIsImZvcm1pa2JhZyIsImNvbXBvbmVudCIsInJlbmRlciIsImlubmVyUmVmIiwib25seSIsIl9yZWY0IiwieXVwRXJyb3IiLCJpbm5lciIsIm1lc3NhZ2UiLCJfaXRlcmF0b3IiLCJfaXNBcnJheSIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiX3JlZjUiLCJuZXh0IiwiZG9uZSIsInN5bmMiLCJjb250ZXh0Iiwibm9ybWFsaXplZFZhbHVlcyIsInByZXBhcmVEYXRhRm9yVmFsaWRhdGlvbiIsImFib3J0RWFybHkiLCJkYXRhIiwiZGVzdGluYXRpb24iLCJmb3JFYWNoIiwibWVyZ2UiLCJjbG9uZVJlcXVlc3RlZCIsInNob3VsZENsb25lIiwiaXNNZXJnZWFibGVPYmplY3QiLCJwdXNoIiwiZnJvbSIsImVsIiwic2VsZWN0ZWQiLCJjdXJyZW50VmFsdWUiLCJCb29sZWFuIiwiY3VycmVudEFycmF5T2ZWYWx1ZXMiLCJpc1ZhbHVlSW5BcnJheSIsImNvbmNhdCIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QiLCJ3aW5kb3ciLCJmbiIsInJlZiIsIl9sZW4iLCJhcmdzIiwiX2tleSIsInVzZUZpZWxkIiwicHJvcHNPckZpZWxkTmFtZSIsImZpZWxkTmFtZSIsInZhbGlkYXRlRm4iLCJmaWVsZEhlbHBlcnMiLCJGaWVsZCIsImNsYXNzTmFtZSIsIl91c2VGb3JtaWtDb250ZXh0IiwibWV0YSIsImxlZ2FjeUJhZyIsImZvcm0iLCJhc0VsZW1lbnQiLCJfaW5uZXJSZWYiLCJfcmVzdCIsIkZvcm0iLCJfYWN0aW9uIiwid2l0aEZvcm1payIsIl9yZWYkbWFwUHJvcHNUb1ZhbHVlcyIsIm1hcFByb3BzVG9WYWx1ZXMiLCJ2YW5pbGxhUHJvcHMiLCJjb25maWciLCJjcmVhdGVGb3JtaWsiLCJDb21wb25lbnQkMSIsImNvbXBvbmVudERpc3BsYXlOYW1lIiwiQyIsIl9SZWFjdCRDb21wb25lbnQiLCJfdGhpcyIsImFjdGlvbnMiLCJyZW5kZXJGb3JtQ29tcG9uZW50IiwiZm9ybWlrUHJvcHMiLCJfcHJvdG8iLCJfdGhpcyRwcm9wcyIsIm1hcFByb3BzVG9TdGF0dXMiLCJtYXBQcm9wc1RvRXJyb3JzIiwibWFwUHJvcHNUb1RvdWNoZWQiLCJjb25uZWN0IiwiQ29tcCIsIldyYXBwZWRDb21wb25lbnQiLCJtb3ZlIiwiYXJyYXkiLCJ0byIsImNvcHkiLCJjb3B5QXJyYXlMaWtlIiwic3BsaWNlIiwic3dhcCIsImFycmF5TGlrZSIsImluZGV4QSIsImluZGV4QiIsImEiLCJpbnNlcnQiLCJyZXBsYWNlIiwibWF4SW5kZXgiLCJwYXJzZUludCIsIm1heCIsImNyZWF0ZUFsdGVyYXRpb25IYW5kbGVyIiwiYWx0ZXJhdGlvbiIsImRlZmF1bHRGdW5jdGlvbiIsIkZpZWxkQXJyYXlJbm5lciIsInVwZGF0ZUFycmF5RmllbGQiLCJhbHRlclRvdWNoZWQiLCJhbHRlckVycm9ycyIsInByZXZTdGF0ZSIsInVwZGF0ZUVycm9ycyIsInVwZGF0ZVRvdWNoZWQiLCJmaWVsZEVycm9yIiwiZmllbGRUb3VjaGVkIiwiaGFuZGxlUHVzaCIsImhhbmRsZVN3YXAiLCJoYW5kbGVNb3ZlIiwiaGFuZGxlSW5zZXJ0IiwiaGFuZGxlUmVwbGFjZSIsInVuc2hpZnQiLCJhcnIiLCJoYW5kbGVVbnNoaWZ0IiwiaGFuZGxlUmVtb3ZlIiwicmVtb3ZlIiwiaGFuZGxlUG9wIiwicG9wIiwiYmluZCIsImNvbXBvbmVudERpZFVwZGF0ZSIsInByZXZQcm9wcyIsImV2ZXJ5IiwidiIsInRtcCIsImFycmF5SGVscGVycyIsIl90aGlzJHByb3BzMiIsIl90aGlzJHByb3BzMiRmb3JtaWsiLCJyZXN0T2ZGb3JtaWsiLCJkZWZhdWx0UHJvcHMiLCJGaWVsZEFycmF5IiwiRXJyb3JNZXNzYWdlSW1wbCIsInNob3VsZENvbXBvbmVudFVwZGF0ZSIsInRvdWNoIiwiRXJyb3JNZXNzYWdlIiwiRmFzdEZpZWxkSW5uZXIiLCJzaG91bGRVcGRhdGUiLCJjb21wb25lbnREaWRNb3VudCIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwiYmFnIiwiRmFzdEZpZWxkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/formik/dist/formik.esm.js\n");

/***/ })

};
;